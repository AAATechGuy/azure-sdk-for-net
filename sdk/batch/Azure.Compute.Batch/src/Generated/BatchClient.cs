// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.Compute.Batch
{
    // Data plane generated client.
    /// <summary> The Batch service client. </summary>
    public partial class BatchClient
    {
        private static readonly string[] AuthorizationScopes = new string[] { "https://batch.core.windows.net//.default" };
        private readonly TokenCredential _tokenCredential;
        private readonly HttpPipeline _pipeline;
        private readonly Uri _endpoint;
        private readonly string _apiVersion;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual HttpPipeline Pipeline => _pipeline;

        /// <summary> Initializes a new instance of BatchClient for mocking. </summary>
        protected BatchClient()
        {
        }

        /// <summary> Initializes a new instance of BatchClient. </summary>
        /// <param name="endpoint"> Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com). </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="endpoint"/> or <paramref name="credential"/> is null. </exception>
        public BatchClient(Uri endpoint, TokenCredential credential) : this(endpoint, credential, new BatchClientOptions())
        {
        }

        /// <summary> Initializes a new instance of BatchClient. </summary>
        /// <param name="endpoint"> Batch account endpoint (for example: https://batchaccount.eastus2.batch.azure.com). </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <param name="options"> The options for configuring the client. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="endpoint"/> or <paramref name="credential"/> is null. </exception>
        public BatchClient(Uri endpoint, TokenCredential credential, BatchClientOptions options)
        {
            Argument.AssertNotNull(endpoint, nameof(endpoint));
            Argument.AssertNotNull(credential, nameof(credential));
            options ??= new BatchClientOptions();

            ClientDiagnostics = new ClientDiagnostics(options, true);
            _tokenCredential = credential;
            _pipeline = HttpPipelineBuilder.Build(options, Array.Empty<HttpPipelinePolicy>(), new HttpPipelinePolicy[] { new BearerTokenAuthenticationPolicy(_tokenCredential, AuthorizationScopes) }, new ResponseClassifier());
            _endpoint = endpoint;
            _apiVersion = options.Version;
        }

        /// <summary> Lists all of the applications available in the specified Account. </summary>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks>
        /// This operation returns only Applications and versions that are available for
        /// use on Compute Nodes; that is, that can be used in an Package reference. For
        /// administrator information about applications and versions that are not yet
        /// available to Compute Nodes, use the Azure portal or the Azure Resource Manager
        /// API.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetApplicationsAsync(int?,DateTimeOffset?,int?,CancellationToken)']/*" />
        public virtual async Task<Response<ApplicationListResult>> GetApplicationsAsync(int? maxresults = null, DateTimeOffset? ocpDate = null, int? timeOut = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetApplicationsAsync(maxresults, ocpDate, timeOut, context).ConfigureAwait(false);
            return Response.FromValue(ApplicationListResult.FromResponse(response), response);
        }

        /// <summary> Lists all of the applications available in the specified Account. </summary>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks>
        /// This operation returns only Applications and versions that are available for
        /// use on Compute Nodes; that is, that can be used in an Package reference. For
        /// administrator information about applications and versions that are not yet
        /// available to Compute Nodes, use the Azure portal or the Azure Resource Manager
        /// API.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetApplications(int?,DateTimeOffset?,int?,CancellationToken)']/*" />
        public virtual Response<ApplicationListResult> GetApplications(int? maxresults = null, DateTimeOffset? ocpDate = null, int? timeOut = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetApplications(maxresults, ocpDate, timeOut, context);
            return Response.FromValue(ApplicationListResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Lists all of the applications available in the specified Account.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetApplicationsAsync(int?,DateTimeOffset?,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetApplicationsAsync(int?,DateTimeOffset?,int?,RequestContext)']/*" />
        public virtual async Task<Response> GetApplicationsAsync(int? maxresults, DateTimeOffset? ocpDate, int? timeOut, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetApplications");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetApplicationsRequest(maxresults, ocpDate, timeOut, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Lists all of the applications available in the specified Account.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetApplications(int?,DateTimeOffset?,int?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetApplications(int?,DateTimeOffset?,int?,RequestContext)']/*" />
        public virtual Response GetApplications(int? maxresults, DateTimeOffset? ocpDate, int? timeOut, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetApplications");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetApplicationsRequest(maxresults, ocpDate, timeOut, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets information about the specified Application. </summary>
        /// <param name="applicationId"> The ID of the Application. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="applicationId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="applicationId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// This operation returns only Applications and versions that are available for
        /// use on Compute Nodes; that is, that can be used in an Package reference. For
        /// administrator information about Applications and versions that are not yet
        /// available to Compute Nodes, use the Azure portal or the Azure Resource Manager
        /// API.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetApplicationAsync(string,int?,DateTimeOffset?,CancellationToken)']/*" />
        public virtual async Task<Response<BatchApplication>> GetApplicationAsync(string applicationId, int? timeOut = null, DateTimeOffset? ocpDate = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(applicationId, nameof(applicationId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetApplicationAsync(applicationId, timeOut, ocpDate, context).ConfigureAwait(false);
            return Response.FromValue(BatchApplication.FromResponse(response), response);
        }

        /// <summary> Gets information about the specified Application. </summary>
        /// <param name="applicationId"> The ID of the Application. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="applicationId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="applicationId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// This operation returns only Applications and versions that are available for
        /// use on Compute Nodes; that is, that can be used in an Package reference. For
        /// administrator information about Applications and versions that are not yet
        /// available to Compute Nodes, use the Azure portal or the Azure Resource Manager
        /// API.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetApplication(string,int?,DateTimeOffset?,CancellationToken)']/*" />
        public virtual Response<BatchApplication> GetApplication(string applicationId, int? timeOut = null, DateTimeOffset? ocpDate = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(applicationId, nameof(applicationId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetApplication(applicationId, timeOut, ocpDate, context);
            return Response.FromValue(BatchApplication.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Gets information about the specified Application.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetApplicationAsync(string,int?,DateTimeOffset?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="applicationId"> The ID of the Application. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="applicationId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="applicationId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetApplicationAsync(string,int?,DateTimeOffset?,RequestContext)']/*" />
        public virtual async Task<Response> GetApplicationAsync(string applicationId, int? timeOut, DateTimeOffset? ocpDate, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(applicationId, nameof(applicationId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetApplication");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetApplicationRequest(applicationId, timeOut, ocpDate, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Gets information about the specified Application.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetApplication(string,int?,DateTimeOffset?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="applicationId"> The ID of the Application. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="applicationId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="applicationId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetApplication(string,int?,DateTimeOffset?,RequestContext)']/*" />
        public virtual Response GetApplication(string applicationId, int? timeOut, DateTimeOffset? ocpDate, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(applicationId, nameof(applicationId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetApplication");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetApplicationRequest(applicationId, timeOut, ocpDate, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Lists the usage metrics, aggregated by Pool across individual time intervals,
        /// for the specified Account.
        /// </summary>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="starttime">
        /// The earliest time from which to include metrics. This must be at least two and
        /// a half hours before the current time. If not specified this defaults to the
        /// start time of the last aggregation interval currently available.
        /// </param>
        /// <param name="endtime">
        /// The latest time from which to include metrics. This must be at least two hours
        /// before the current time. If not specified this defaults to the end time of the
        /// last aggregation interval currently available.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-account-usage-metrics.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks>
        /// If you do not specify a $filter clause including a poolId, the response
        /// includes all Pools that existed in the Account in the time range of the
        /// returned aggregation intervals. If you do not specify a $filter clause
        /// including a startTime or endTime these filters default to the start and end
        /// times of the last aggregation interval currently available; that is, only the
        /// last aggregation interval is returned.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetPoolUsageMetricsAsync(int?,DateTimeOffset?,int?,DateTimeOffset?,DateTimeOffset?,string,CancellationToken)']/*" />
        public virtual async Task<Response<PoolListUsageMetricsResult>> GetPoolUsageMetricsAsync(int? maxresults = null, DateTimeOffset? ocpDate = null, int? timeOut = null, DateTimeOffset? starttime = null, DateTimeOffset? endtime = null, string filter = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetPoolUsageMetricsAsync(maxresults, ocpDate, timeOut, starttime, endtime, filter, context).ConfigureAwait(false);
            return Response.FromValue(PoolListUsageMetricsResult.FromResponse(response), response);
        }

        /// <summary>
        /// Lists the usage metrics, aggregated by Pool across individual time intervals,
        /// for the specified Account.
        /// </summary>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="starttime">
        /// The earliest time from which to include metrics. This must be at least two and
        /// a half hours before the current time. If not specified this defaults to the
        /// start time of the last aggregation interval currently available.
        /// </param>
        /// <param name="endtime">
        /// The latest time from which to include metrics. This must be at least two hours
        /// before the current time. If not specified this defaults to the end time of the
        /// last aggregation interval currently available.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-account-usage-metrics.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <remarks>
        /// If you do not specify a $filter clause including a poolId, the response
        /// includes all Pools that existed in the Account in the time range of the
        /// returned aggregation intervals. If you do not specify a $filter clause
        /// including a startTime or endTime these filters default to the start and end
        /// times of the last aggregation interval currently available; that is, only the
        /// last aggregation interval is returned.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetPoolUsageMetrics(int?,DateTimeOffset?,int?,DateTimeOffset?,DateTimeOffset?,string,CancellationToken)']/*" />
        public virtual Response<PoolListUsageMetricsResult> GetPoolUsageMetrics(int? maxresults = null, DateTimeOffset? ocpDate = null, int? timeOut = null, DateTimeOffset? starttime = null, DateTimeOffset? endtime = null, string filter = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetPoolUsageMetrics(maxresults, ocpDate, timeOut, starttime, endtime, filter, context);
            return Response.FromValue(PoolListUsageMetricsResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Lists the usage metrics, aggregated by Pool across individual time intervals,
        /// for the specified Account.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPoolUsageMetricsAsync(int?,DateTimeOffset?,int?,DateTimeOffset?,DateTimeOffset?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="starttime">
        /// The earliest time from which to include metrics. This must be at least two and
        /// a half hours before the current time. If not specified this defaults to the
        /// start time of the last aggregation interval currently available.
        /// </param>
        /// <param name="endtime">
        /// The latest time from which to include metrics. This must be at least two hours
        /// before the current time. If not specified this defaults to the end time of the
        /// last aggregation interval currently available.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-account-usage-metrics.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetPoolUsageMetricsAsync(int?,DateTimeOffset?,int?,DateTimeOffset?,DateTimeOffset?,string,RequestContext)']/*" />
        public virtual async Task<Response> GetPoolUsageMetricsAsync(int? maxresults, DateTimeOffset? ocpDate, int? timeOut, DateTimeOffset? starttime, DateTimeOffset? endtime, string filter, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetPoolUsageMetrics");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPoolUsageMetricsRequest(maxresults, ocpDate, timeOut, starttime, endtime, filter, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Lists the usage metrics, aggregated by Pool across individual time intervals,
        /// for the specified Account.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPoolUsageMetrics(int?,DateTimeOffset?,int?,DateTimeOffset?,DateTimeOffset?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="starttime">
        /// The earliest time from which to include metrics. This must be at least two and
        /// a half hours before the current time. If not specified this defaults to the
        /// start time of the last aggregation interval currently available.
        /// </param>
        /// <param name="endtime">
        /// The latest time from which to include metrics. This must be at least two hours
        /// before the current time. If not specified this defaults to the end time of the
        /// last aggregation interval currently available.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-account-usage-metrics.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetPoolUsageMetrics(int?,DateTimeOffset?,int?,DateTimeOffset?,DateTimeOffset?,string,RequestContext)']/*" />
        public virtual Response GetPoolUsageMetrics(int? maxresults, DateTimeOffset? ocpDate, int? timeOut, DateTimeOffset? starttime, DateTimeOffset? endtime, string filter, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetPoolUsageMetrics");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPoolUsageMetricsRequest(maxresults, ocpDate, timeOut, starttime, endtime, filter, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Creates a Pool to the specified Account. </summary>
        /// <param name="body"> The Pool to be created. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="body"/> is null. </exception>
        /// <remarks>
        /// When naming Pools, avoid including sensitive information such as user names or
        /// secret project names. This information may appear in telemetry logs accessible
        /// to Microsoft Support engineers.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='CreateAsync(BatchPoolCreateOptions,int?,DateTimeOffset?,CancellationToken)']/*" />
        public virtual async Task<Response> CreateAsync(BatchPoolCreateOptions body, int? timeOut = null, DateTimeOffset? ocpDate = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(body, nameof(body));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = body.ToRequestContent();
            Response response = await CreateAsync(content, timeOut, ocpDate, context).ConfigureAwait(false);
            return response;
        }

        /// <summary> Creates a Pool to the specified Account. </summary>
        /// <param name="body"> The Pool to be created. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="body"/> is null. </exception>
        /// <remarks>
        /// When naming Pools, avoid including sensitive information such as user names or
        /// secret project names. This information may appear in telemetry logs accessible
        /// to Microsoft Support engineers.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='Create(BatchPoolCreateOptions,int?,DateTimeOffset?,CancellationToken)']/*" />
        public virtual Response Create(BatchPoolCreateOptions body, int? timeOut = null, DateTimeOffset? ocpDate = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(body, nameof(body));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = body.ToRequestContent();
            Response response = Create(content, timeOut, ocpDate, context);
            return response;
        }

        /// <summary>
        /// [Protocol Method] Creates a Pool to the specified Account.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateAsync(BatchPoolCreateOptions,int?,DateTimeOffset?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='CreateAsync(RequestContent,int?,DateTimeOffset?,RequestContext)']/*" />
        public virtual async Task<Response> CreateAsync(RequestContent content, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.Create");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateRequest(content, timeOut, ocpDate, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Creates a Pool to the specified Account.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="Create(BatchPoolCreateOptions,int?,DateTimeOffset?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='Create(RequestContent,int?,DateTimeOffset?,RequestContext)']/*" />
        public virtual Response Create(RequestContent content, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.Create");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateRequest(content, timeOut, ocpDate, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Lists all of the Pools in the specified Account. </summary>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-pools.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="expand"> An OData $expand clause. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetPoolsAsync(int?,DateTimeOffset?,int?,string,IEnumerable{string},IEnumerable{string},CancellationToken)']/*" />
        public virtual async Task<Response<BatchPoolListResult>> GetPoolsAsync(int? maxresults = null, DateTimeOffset? ocpDate = null, int? timeOut = null, string filter = null, IEnumerable<string> select = null, IEnumerable<string> expand = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetPoolsAsync(maxresults, ocpDate, timeOut, filter, select, expand, context).ConfigureAwait(false);
            return Response.FromValue(BatchPoolListResult.FromResponse(response), response);
        }

        /// <summary> Lists all of the Pools in the specified Account. </summary>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-pools.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="expand"> An OData $expand clause. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetPools(int?,DateTimeOffset?,int?,string,IEnumerable{string},IEnumerable{string},CancellationToken)']/*" />
        public virtual Response<BatchPoolListResult> GetPools(int? maxresults = null, DateTimeOffset? ocpDate = null, int? timeOut = null, string filter = null, IEnumerable<string> select = null, IEnumerable<string> expand = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetPools(maxresults, ocpDate, timeOut, filter, select, expand, context);
            return Response.FromValue(BatchPoolListResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Lists all of the Pools in the specified Account.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPoolsAsync(int?,DateTimeOffset?,int?,string,IEnumerable{string},IEnumerable{string},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-pools.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="expand"> An OData $expand clause. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetPoolsAsync(int?,DateTimeOffset?,int?,string,IEnumerable{string},IEnumerable{string},RequestContext)']/*" />
        public virtual async Task<Response> GetPoolsAsync(int? maxresults, DateTimeOffset? ocpDate, int? timeOut, string filter, IEnumerable<string> select, IEnumerable<string> expand, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetPools");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPoolsRequest(maxresults, ocpDate, timeOut, filter, select, expand, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Lists all of the Pools in the specified Account.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPools(int?,DateTimeOffset?,int?,string,IEnumerable{string},IEnumerable{string},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-pools.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="expand"> An OData $expand clause. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetPools(int?,DateTimeOffset?,int?,string,IEnumerable{string},IEnumerable{string},RequestContext)']/*" />
        public virtual Response GetPools(int? maxresults, DateTimeOffset? ocpDate, int? timeOut, string filter, IEnumerable<string> select, IEnumerable<string> expand, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetPools");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPoolsRequest(maxresults, ocpDate, timeOut, filter, select, expand, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Deletes a Pool from the specified Account.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool to get. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='DeleteAsync(string,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual async Task<Response> DeleteAsync(string poolId, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.Delete");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteRequest(poolId, timeOut, ocpDate, requestConditions, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Deletes a Pool from the specified Account.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool to get. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='Delete(string,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual Response Delete(string poolId, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.Delete");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteRequest(poolId, timeOut, ocpDate, requestConditions, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Gets basic properties of a Pool.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool to get. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='PoolExistsAsync(string,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual async Task<Response<bool>> PoolExistsAsync(string poolId, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.PoolExists");
            scope.Start();
            try
            {
                using HttpMessage message = CreatePoolExistsRequest(poolId, timeOut, ocpDate, requestConditions, context);
                return await _pipeline.ProcessHeadAsBoolMessageAsync(message, ClientDiagnostics, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Gets basic properties of a Pool.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool to get. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='PoolExists(string,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual Response<bool> PoolExists(string poolId, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.PoolExists");
            scope.Start();
            try
            {
                using HttpMessage message = CreatePoolExistsRequest(poolId, timeOut, ocpDate, requestConditions, context);
                return _pipeline.ProcessHeadAsBoolMessage(message, ClientDiagnostics, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets information about the specified Pool. </summary>
        /// <param name="poolId"> The ID of the Pool to get. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="expand"> An OData $expand clause. </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetPoolAsync(string,int?,DateTimeOffset?,IEnumerable{string},IEnumerable{string},RequestConditions,CancellationToken)']/*" />
        public virtual async Task<Response<BatchPool>> GetPoolAsync(string poolId, int? timeOut = null, DateTimeOffset? ocpDate = null, IEnumerable<string> select = null, IEnumerable<string> expand = null, RequestConditions requestConditions = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetPoolAsync(poolId, timeOut, ocpDate, select, expand, requestConditions, context).ConfigureAwait(false);
            return Response.FromValue(BatchPool.FromResponse(response), response);
        }

        /// <summary> Gets information about the specified Pool. </summary>
        /// <param name="poolId"> The ID of the Pool to get. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="expand"> An OData $expand clause. </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetPool(string,int?,DateTimeOffset?,IEnumerable{string},IEnumerable{string},RequestConditions,CancellationToken)']/*" />
        public virtual Response<BatchPool> GetPool(string poolId, int? timeOut = null, DateTimeOffset? ocpDate = null, IEnumerable<string> select = null, IEnumerable<string> expand = null, RequestConditions requestConditions = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetPool(poolId, timeOut, ocpDate, select, expand, requestConditions, context);
            return Response.FromValue(BatchPool.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Gets information about the specified Pool.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPoolAsync(string,int?,DateTimeOffset?,IEnumerable{string},IEnumerable{string},RequestConditions,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool to get. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="expand"> An OData $expand clause. </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetPoolAsync(string,int?,DateTimeOffset?,IEnumerable{string},IEnumerable{string},RequestConditions,RequestContext)']/*" />
        public virtual async Task<Response> GetPoolAsync(string poolId, int? timeOut, DateTimeOffset? ocpDate, IEnumerable<string> select, IEnumerable<string> expand, RequestConditions requestConditions, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetPool");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPoolRequest(poolId, timeOut, ocpDate, select, expand, requestConditions, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Gets information about the specified Pool.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPool(string,int?,DateTimeOffset?,IEnumerable{string},IEnumerable{string},RequestConditions,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool to get. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="expand"> An OData $expand clause. </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetPool(string,int?,DateTimeOffset?,IEnumerable{string},IEnumerable{string},RequestConditions,RequestContext)']/*" />
        public virtual Response GetPool(string poolId, int? timeOut, DateTimeOffset? ocpDate, IEnumerable<string> select, IEnumerable<string> expand, RequestConditions requestConditions, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetPool");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPoolRequest(poolId, timeOut, ocpDate, select, expand, requestConditions, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Updates the properties of the specified Pool.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool to get. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='UpdateAsync(string,RequestContent,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual async Task<Response> UpdateAsync(string poolId, RequestContent content, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.Update");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateRequest(poolId, content, timeOut, ocpDate, requestConditions, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Updates the properties of the specified Pool.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool to get. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='Update(string,RequestContent,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual Response Update(string poolId, RequestContent content, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.Update");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateRequest(poolId, content, timeOut, ocpDate, requestConditions, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Disables automatic scaling for a Pool.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool on which to disable automatic scaling. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='DisablePoolAutoScaleAsync(string,int?,DateTimeOffset?,RequestContext)']/*" />
        public virtual async Task<Response> DisablePoolAutoScaleAsync(string poolId, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.DisablePoolAutoScale");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDisablePoolAutoScaleRequest(poolId, timeOut, ocpDate, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Disables automatic scaling for a Pool.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool on which to disable automatic scaling. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='DisablePoolAutoScale(string,int?,DateTimeOffset?,RequestContext)']/*" />
        public virtual Response DisablePoolAutoScale(string poolId, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.DisablePoolAutoScale");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDisablePoolAutoScaleRequest(poolId, timeOut, ocpDate, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Enables automatic scaling for a Pool. </summary>
        /// <param name="poolId"> The ID of the Pool to get. </param>
        /// <param name="body"> The options to use for enabling automatic scaling. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// You cannot enable automatic scaling on a Pool if a resize operation is in
        /// progress on the Pool. If automatic scaling of the Pool is currently disabled,
        /// you must specify a valid autoscale formula as part of the request. If automatic
        /// scaling of the Pool is already enabled, you may specify a new autoscale formula
        /// and/or a new evaluation interval. You cannot call this API for the same Pool
        /// more than once every 30 seconds.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='EnablePoolAutoScaleAsync(string,BatchPoolEnableAutoScaleOptions,int?,DateTimeOffset?,RequestConditions,CancellationToken)']/*" />
        public virtual async Task<Response> EnablePoolAutoScaleAsync(string poolId, BatchPoolEnableAutoScaleOptions body, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNull(body, nameof(body));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = body.ToRequestContent();
            Response response = await EnablePoolAutoScaleAsync(poolId, content, timeOut, ocpDate, requestConditions, context).ConfigureAwait(false);
            return response;
        }

        /// <summary> Enables automatic scaling for a Pool. </summary>
        /// <param name="poolId"> The ID of the Pool to get. </param>
        /// <param name="body"> The options to use for enabling automatic scaling. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// You cannot enable automatic scaling on a Pool if a resize operation is in
        /// progress on the Pool. If automatic scaling of the Pool is currently disabled,
        /// you must specify a valid autoscale formula as part of the request. If automatic
        /// scaling of the Pool is already enabled, you may specify a new autoscale formula
        /// and/or a new evaluation interval. You cannot call this API for the same Pool
        /// more than once every 30 seconds.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='EnablePoolAutoScale(string,BatchPoolEnableAutoScaleOptions,int?,DateTimeOffset?,RequestConditions,CancellationToken)']/*" />
        public virtual Response EnablePoolAutoScale(string poolId, BatchPoolEnableAutoScaleOptions body, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNull(body, nameof(body));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = body.ToRequestContent();
            Response response = EnablePoolAutoScale(poolId, content, timeOut, ocpDate, requestConditions, context);
            return response;
        }

        /// <summary>
        /// [Protocol Method] Enables automatic scaling for a Pool.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="EnablePoolAutoScaleAsync(string,BatchPoolEnableAutoScaleOptions,int?,DateTimeOffset?,RequestConditions,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool to get. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='EnablePoolAutoScaleAsync(string,RequestContent,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual async Task<Response> EnablePoolAutoScaleAsync(string poolId, RequestContent content, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.EnablePoolAutoScale");
            scope.Start();
            try
            {
                using HttpMessage message = CreateEnablePoolAutoScaleRequest(poolId, content, timeOut, ocpDate, requestConditions, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Enables automatic scaling for a Pool.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="EnablePoolAutoScale(string,BatchPoolEnableAutoScaleOptions,int?,DateTimeOffset?,RequestConditions,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool to get. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='EnablePoolAutoScale(string,RequestContent,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual Response EnablePoolAutoScale(string poolId, RequestContent content, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.EnablePoolAutoScale");
            scope.Start();
            try
            {
                using HttpMessage message = CreateEnablePoolAutoScaleRequest(poolId, content, timeOut, ocpDate, requestConditions, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the result of evaluating an automatic scaling formula on the Pool. </summary>
        /// <param name="poolId"> The ID of the Pool on which to evaluate the automatic scaling formula. </param>
        /// <param name="body"> The options to use for evaluating the automatic scaling formula. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// This API is primarily for validating an autoscale formula, as it simply returns
        /// the result without applying the formula to the Pool. The Pool must have auto
        /// scaling enabled in order to evaluate a formula.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='EvaluatePoolAutoScaleAsync(string,BatchPoolEvaluateAutoScaleOptions,int?,DateTimeOffset?,CancellationToken)']/*" />
        public virtual async Task<Response<AutoScaleRun>> EvaluatePoolAutoScaleAsync(string poolId, BatchPoolEvaluateAutoScaleOptions body, int? timeOut = null, DateTimeOffset? ocpDate = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNull(body, nameof(body));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = body.ToRequestContent();
            Response response = await EvaluatePoolAutoScaleAsync(poolId, content, timeOut, ocpDate, context).ConfigureAwait(false);
            return Response.FromValue(AutoScaleRun.FromResponse(response), response);
        }

        /// <summary> Gets the result of evaluating an automatic scaling formula on the Pool. </summary>
        /// <param name="poolId"> The ID of the Pool on which to evaluate the automatic scaling formula. </param>
        /// <param name="body"> The options to use for evaluating the automatic scaling formula. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// This API is primarily for validating an autoscale formula, as it simply returns
        /// the result without applying the formula to the Pool. The Pool must have auto
        /// scaling enabled in order to evaluate a formula.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='EvaluatePoolAutoScale(string,BatchPoolEvaluateAutoScaleOptions,int?,DateTimeOffset?,CancellationToken)']/*" />
        public virtual Response<AutoScaleRun> EvaluatePoolAutoScale(string poolId, BatchPoolEvaluateAutoScaleOptions body, int? timeOut = null, DateTimeOffset? ocpDate = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNull(body, nameof(body));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = body.ToRequestContent();
            Response response = EvaluatePoolAutoScale(poolId, content, timeOut, ocpDate, context);
            return Response.FromValue(AutoScaleRun.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Gets the result of evaluating an automatic scaling formula on the Pool.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="EvaluatePoolAutoScaleAsync(string,BatchPoolEvaluateAutoScaleOptions,int?,DateTimeOffset?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool on which to evaluate the automatic scaling formula. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='EvaluatePoolAutoScaleAsync(string,RequestContent,int?,DateTimeOffset?,RequestContext)']/*" />
        public virtual async Task<Response> EvaluatePoolAutoScaleAsync(string poolId, RequestContent content, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.EvaluatePoolAutoScale");
            scope.Start();
            try
            {
                using HttpMessage message = CreateEvaluatePoolAutoScaleRequest(poolId, content, timeOut, ocpDate, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Gets the result of evaluating an automatic scaling formula on the Pool.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="EvaluatePoolAutoScale(string,BatchPoolEvaluateAutoScaleOptions,int?,DateTimeOffset?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool on which to evaluate the automatic scaling formula. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='EvaluatePoolAutoScale(string,RequestContent,int?,DateTimeOffset?,RequestContext)']/*" />
        public virtual Response EvaluatePoolAutoScale(string poolId, RequestContent content, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.EvaluatePoolAutoScale");
            scope.Start();
            try
            {
                using HttpMessage message = CreateEvaluatePoolAutoScaleRequest(poolId, content, timeOut, ocpDate, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Changes the number of Compute Nodes that are assigned to a Pool. </summary>
        /// <param name="poolId"> The ID of the Pool to get. </param>
        /// <param name="body"> The options to use for resizing the pool. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// You can only resize a Pool when its allocation state is steady. If the Pool is
        /// already resizing, the request fails with status code 409. When you resize a
        /// Pool, the Pool's allocation state changes from steady to resizing. You cannot
        /// resize Pools which are configured for automatic scaling. If you try to do this,
        /// the Batch service returns an error 409. If you resize a Pool downwards, the
        /// Batch service chooses which Compute Nodes to remove. To remove specific Compute
        /// Nodes, use the Pool remove Compute Nodes API instead.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='ResizeAsync(string,BatchPoolResizeOptions,int?,DateTimeOffset?,RequestConditions,CancellationToken)']/*" />
        public virtual async Task<Response> ResizeAsync(string poolId, BatchPoolResizeOptions body, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNull(body, nameof(body));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = body.ToRequestContent();
            Response response = await ResizeAsync(poolId, content, timeOut, ocpDate, requestConditions, context).ConfigureAwait(false);
            return response;
        }

        /// <summary> Changes the number of Compute Nodes that are assigned to a Pool. </summary>
        /// <param name="poolId"> The ID of the Pool to get. </param>
        /// <param name="body"> The options to use for resizing the pool. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// You can only resize a Pool when its allocation state is steady. If the Pool is
        /// already resizing, the request fails with status code 409. When you resize a
        /// Pool, the Pool's allocation state changes from steady to resizing. You cannot
        /// resize Pools which are configured for automatic scaling. If you try to do this,
        /// the Batch service returns an error 409. If you resize a Pool downwards, the
        /// Batch service chooses which Compute Nodes to remove. To remove specific Compute
        /// Nodes, use the Pool remove Compute Nodes API instead.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='Resize(string,BatchPoolResizeOptions,int?,DateTimeOffset?,RequestConditions,CancellationToken)']/*" />
        public virtual Response Resize(string poolId, BatchPoolResizeOptions body, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNull(body, nameof(body));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = body.ToRequestContent();
            Response response = Resize(poolId, content, timeOut, ocpDate, requestConditions, context);
            return response;
        }

        /// <summary>
        /// [Protocol Method] Changes the number of Compute Nodes that are assigned to a Pool.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="ResizeAsync(string,BatchPoolResizeOptions,int?,DateTimeOffset?,RequestConditions,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool to get. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='ResizeAsync(string,RequestContent,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual async Task<Response> ResizeAsync(string poolId, RequestContent content, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.Resize");
            scope.Start();
            try
            {
                using HttpMessage message = CreateResizeRequest(poolId, content, timeOut, ocpDate, requestConditions, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Changes the number of Compute Nodes that are assigned to a Pool.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="Resize(string,BatchPoolResizeOptions,int?,DateTimeOffset?,RequestConditions,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool to get. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='Resize(string,RequestContent,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual Response Resize(string poolId, RequestContent content, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.Resize");
            scope.Start();
            try
            {
                using HttpMessage message = CreateResizeRequest(poolId, content, timeOut, ocpDate, requestConditions, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Stops an ongoing resize operation on the Pool.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool to get. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='StopPoolResizeAsync(string,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual async Task<Response> StopPoolResizeAsync(string poolId, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.StopPoolResize");
            scope.Start();
            try
            {
                using HttpMessage message = CreateStopPoolResizeRequest(poolId, timeOut, ocpDate, requestConditions, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Stops an ongoing resize operation on the Pool.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool to get. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='StopPoolResize(string,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual Response StopPoolResize(string poolId, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.StopPoolResize");
            scope.Start();
            try
            {
                using HttpMessage message = CreateStopPoolResizeRequest(poolId, timeOut, ocpDate, requestConditions, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Updates the properties of the specified Pool. </summary>
        /// <param name="poolId"> The ID of the Pool to update. </param>
        /// <param name="body"> The options to use for replacing properties on the pool. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// This fully replaces all the updatable properties of the Pool. For example, if
        /// the Pool has a StartTask associated with it and if StartTask is not specified
        /// with this request, then the Batch service will remove the existing StartTask.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='ReplacePoolPropertiesAsync(string,BatchPoolReplaceOptions,int?,DateTimeOffset?,CancellationToken)']/*" />
        public virtual async Task<Response> ReplacePoolPropertiesAsync(string poolId, BatchPoolReplaceOptions body, int? timeOut = null, DateTimeOffset? ocpDate = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNull(body, nameof(body));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = body.ToRequestContent();
            Response response = await ReplacePoolPropertiesAsync(poolId, content, timeOut, ocpDate, context).ConfigureAwait(false);
            return response;
        }

        /// <summary> Updates the properties of the specified Pool. </summary>
        /// <param name="poolId"> The ID of the Pool to update. </param>
        /// <param name="body"> The options to use for replacing properties on the pool. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// This fully replaces all the updatable properties of the Pool. For example, if
        /// the Pool has a StartTask associated with it and if StartTask is not specified
        /// with this request, then the Batch service will remove the existing StartTask.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='ReplacePoolProperties(string,BatchPoolReplaceOptions,int?,DateTimeOffset?,CancellationToken)']/*" />
        public virtual Response ReplacePoolProperties(string poolId, BatchPoolReplaceOptions body, int? timeOut = null, DateTimeOffset? ocpDate = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNull(body, nameof(body));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = body.ToRequestContent();
            Response response = ReplacePoolProperties(poolId, content, timeOut, ocpDate, context);
            return response;
        }

        /// <summary>
        /// [Protocol Method] Updates the properties of the specified Pool.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="ReplacePoolPropertiesAsync(string,BatchPoolReplaceOptions,int?,DateTimeOffset?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool to update. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='ReplacePoolPropertiesAsync(string,RequestContent,int?,DateTimeOffset?,RequestContext)']/*" />
        public virtual async Task<Response> ReplacePoolPropertiesAsync(string poolId, RequestContent content, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.ReplacePoolProperties");
            scope.Start();
            try
            {
                using HttpMessage message = CreateReplacePoolPropertiesRequest(poolId, content, timeOut, ocpDate, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Updates the properties of the specified Pool.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="ReplacePoolProperties(string,BatchPoolReplaceOptions,int?,DateTimeOffset?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool to update. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='ReplacePoolProperties(string,RequestContent,int?,DateTimeOffset?,RequestContext)']/*" />
        public virtual Response ReplacePoolProperties(string poolId, RequestContent content, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.ReplacePoolProperties");
            scope.Start();
            try
            {
                using HttpMessage message = CreateReplacePoolPropertiesRequest(poolId, content, timeOut, ocpDate, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Removes Compute Nodes from the specified Pool. </summary>
        /// <param name="poolId"> The ID of the Pool to get. </param>
        /// <param name="body"> The options to use for removing the node. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// This operation can only run when the allocation state of the Pool is steady.
        /// When this operation runs, the allocation state changes from steady to resizing.
        /// Each request may remove up to 100 nodes.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='RemoveNodesAsync(string,NodeRemoveOptions,int?,DateTimeOffset?,RequestConditions,CancellationToken)']/*" />
        public virtual async Task<Response> RemoveNodesAsync(string poolId, NodeRemoveOptions body, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNull(body, nameof(body));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = body.ToRequestContent();
            Response response = await RemoveNodesAsync(poolId, content, timeOut, ocpDate, requestConditions, context).ConfigureAwait(false);
            return response;
        }

        /// <summary> Removes Compute Nodes from the specified Pool. </summary>
        /// <param name="poolId"> The ID of the Pool to get. </param>
        /// <param name="body"> The options to use for removing the node. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// This operation can only run when the allocation state of the Pool is steady.
        /// When this operation runs, the allocation state changes from steady to resizing.
        /// Each request may remove up to 100 nodes.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='RemoveNodes(string,NodeRemoveOptions,int?,DateTimeOffset?,RequestConditions,CancellationToken)']/*" />
        public virtual Response RemoveNodes(string poolId, NodeRemoveOptions body, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNull(body, nameof(body));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = body.ToRequestContent();
            Response response = RemoveNodes(poolId, content, timeOut, ocpDate, requestConditions, context);
            return response;
        }

        /// <summary>
        /// [Protocol Method] Removes Compute Nodes from the specified Pool.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="RemoveNodesAsync(string,NodeRemoveOptions,int?,DateTimeOffset?,RequestConditions,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool to get. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='RemoveNodesAsync(string,RequestContent,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual async Task<Response> RemoveNodesAsync(string poolId, RequestContent content, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.RemoveNodes");
            scope.Start();
            try
            {
                using HttpMessage message = CreateRemoveNodesRequest(poolId, content, timeOut, ocpDate, requestConditions, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Removes Compute Nodes from the specified Pool.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="RemoveNodes(string,NodeRemoveOptions,int?,DateTimeOffset?,RequestConditions,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool to get. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='RemoveNodes(string,RequestContent,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual Response RemoveNodes(string poolId, RequestContent content, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.RemoveNodes");
            scope.Start();
            try
            {
                using HttpMessage message = CreateRemoveNodesRequest(poolId, content, timeOut, ocpDate, requestConditions, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Lists all Virtual Machine Images supported by the Azure Batch service. </summary>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-support-images.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetSupportedImagesAsync(int?,DateTimeOffset?,int?,string,CancellationToken)']/*" />
        public virtual async Task<Response<AccountListSupportedImagesResult>> GetSupportedImagesAsync(int? maxresults = null, DateTimeOffset? ocpDate = null, int? timeOut = null, string filter = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetSupportedImagesAsync(maxresults, ocpDate, timeOut, filter, context).ConfigureAwait(false);
            return Response.FromValue(AccountListSupportedImagesResult.FromResponse(response), response);
        }

        /// <summary> Lists all Virtual Machine Images supported by the Azure Batch service. </summary>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-support-images.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetSupportedImages(int?,DateTimeOffset?,int?,string,CancellationToken)']/*" />
        public virtual Response<AccountListSupportedImagesResult> GetSupportedImages(int? maxresults = null, DateTimeOffset? ocpDate = null, int? timeOut = null, string filter = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetSupportedImages(maxresults, ocpDate, timeOut, filter, context);
            return Response.FromValue(AccountListSupportedImagesResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Lists all Virtual Machine Images supported by the Azure Batch service.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetSupportedImagesAsync(int?,DateTimeOffset?,int?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-support-images.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetSupportedImagesAsync(int?,DateTimeOffset?,int?,string,RequestContext)']/*" />
        public virtual async Task<Response> GetSupportedImagesAsync(int? maxresults, DateTimeOffset? ocpDate, int? timeOut, string filter, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetSupportedImages");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetSupportedImagesRequest(maxresults, ocpDate, timeOut, filter, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Lists all Virtual Machine Images supported by the Azure Batch service.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetSupportedImages(int?,DateTimeOffset?,int?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-support-images.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetSupportedImages(int?,DateTimeOffset?,int?,string,RequestContext)']/*" />
        public virtual Response GetSupportedImages(int? maxresults, DateTimeOffset? ocpDate, int? timeOut, string filter, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetSupportedImages");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetSupportedImagesRequest(maxresults, ocpDate, timeOut, filter, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Gets the number of Compute Nodes in each state, grouped by Pool. Note that the
        /// numbers returned may not always be up to date. If you need exact node counts,
        /// use a list query.
        /// </summary>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-support-images.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetPoolNodeCountsAsync(int?,DateTimeOffset?,int?,string,CancellationToken)']/*" />
        public virtual async Task<Response<PoolNodeCountsListResult>> GetPoolNodeCountsAsync(int? maxresults = null, DateTimeOffset? ocpDate = null, int? timeOut = null, string filter = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetPoolNodeCountsAsync(maxresults, ocpDate, timeOut, filter, context).ConfigureAwait(false);
            return Response.FromValue(PoolNodeCountsListResult.FromResponse(response), response);
        }

        /// <summary>
        /// Gets the number of Compute Nodes in each state, grouped by Pool. Note that the
        /// numbers returned may not always be up to date. If you need exact node counts,
        /// use a list query.
        /// </summary>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-support-images.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetPoolNodeCounts(int?,DateTimeOffset?,int?,string,CancellationToken)']/*" />
        public virtual Response<PoolNodeCountsListResult> GetPoolNodeCounts(int? maxresults = null, DateTimeOffset? ocpDate = null, int? timeOut = null, string filter = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetPoolNodeCounts(maxresults, ocpDate, timeOut, filter, context);
            return Response.FromValue(PoolNodeCountsListResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Gets the number of Compute Nodes in each state, grouped by Pool. Note that the
        /// numbers returned may not always be up to date. If you need exact node counts,
        /// use a list query.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPoolNodeCountsAsync(int?,DateTimeOffset?,int?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-support-images.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetPoolNodeCountsAsync(int?,DateTimeOffset?,int?,string,RequestContext)']/*" />
        public virtual async Task<Response> GetPoolNodeCountsAsync(int? maxresults, DateTimeOffset? ocpDate, int? timeOut, string filter, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetPoolNodeCounts");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPoolNodeCountsRequest(maxresults, ocpDate, timeOut, filter, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Gets the number of Compute Nodes in each state, grouped by Pool. Note that the
        /// numbers returned may not always be up to date. If you need exact node counts,
        /// use a list query.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetPoolNodeCounts(int?,DateTimeOffset?,int?,string,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-support-images.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetPoolNodeCounts(int?,DateTimeOffset?,int?,string,RequestContext)']/*" />
        public virtual Response GetPoolNodeCounts(int? maxresults, DateTimeOffset? ocpDate, int? timeOut, string filter, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetPoolNodeCounts");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPoolNodeCountsRequest(maxresults, ocpDate, timeOut, filter, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Deletes a Job.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobId"> The ID of the Job to delete. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='DeleteJobAsync(string,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual async Task<Response> DeleteJobAsync(string jobId, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.DeleteJob");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteJobRequest(jobId, timeOut, ocpDate, requestConditions, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Deletes a Job.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobId"> The ID of the Job to delete. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='DeleteJob(string,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual Response DeleteJob(string jobId, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.DeleteJob");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteJobRequest(jobId, timeOut, ocpDate, requestConditions, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets information about the specified Job. </summary>
        /// <param name="jobId"> The ID of the Job. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="expand"> An OData $expand clause. </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetJobAsync(string,int?,DateTimeOffset?,IEnumerable{string},IEnumerable{string},RequestConditions,CancellationToken)']/*" />
        public virtual async Task<Response<BatchJob>> GetJobAsync(string jobId, int? timeOut = null, DateTimeOffset? ocpDate = null, IEnumerable<string> select = null, IEnumerable<string> expand = null, RequestConditions requestConditions = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetJobAsync(jobId, timeOut, ocpDate, select, expand, requestConditions, context).ConfigureAwait(false);
            return Response.FromValue(BatchJob.FromResponse(response), response);
        }

        /// <summary> Gets information about the specified Job. </summary>
        /// <param name="jobId"> The ID of the Job. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="expand"> An OData $expand clause. </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetJob(string,int?,DateTimeOffset?,IEnumerable{string},IEnumerable{string},RequestConditions,CancellationToken)']/*" />
        public virtual Response<BatchJob> GetJob(string jobId, int? timeOut = null, DateTimeOffset? ocpDate = null, IEnumerable<string> select = null, IEnumerable<string> expand = null, RequestConditions requestConditions = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetJob(jobId, timeOut, ocpDate, select, expand, requestConditions, context);
            return Response.FromValue(BatchJob.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Gets information about the specified Job.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetJobAsync(string,int?,DateTimeOffset?,IEnumerable{string},IEnumerable{string},RequestConditions,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobId"> The ID of the Job. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="expand"> An OData $expand clause. </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetJobAsync(string,int?,DateTimeOffset?,IEnumerable{string},IEnumerable{string},RequestConditions,RequestContext)']/*" />
        public virtual async Task<Response> GetJobAsync(string jobId, int? timeOut, DateTimeOffset? ocpDate, IEnumerable<string> select, IEnumerable<string> expand, RequestConditions requestConditions, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetJob");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetJobRequest(jobId, timeOut, ocpDate, select, expand, requestConditions, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Gets information about the specified Job.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetJob(string,int?,DateTimeOffset?,IEnumerable{string},IEnumerable{string},RequestConditions,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobId"> The ID of the Job. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="expand"> An OData $expand clause. </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetJob(string,int?,DateTimeOffset?,IEnumerable{string},IEnumerable{string},RequestConditions,RequestContext)']/*" />
        public virtual Response GetJob(string jobId, int? timeOut, DateTimeOffset? ocpDate, IEnumerable<string> select, IEnumerable<string> expand, RequestConditions requestConditions, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetJob");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetJobRequest(jobId, timeOut, ocpDate, select, expand, requestConditions, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Updates the properties of the specified Job.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobId"> The ID of the Job whose properties you want to update. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='UpdateJobAsync(string,RequestContent,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual async Task<Response> UpdateJobAsync(string jobId, RequestContent content, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.UpdateJob");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateJobRequest(jobId, content, timeOut, ocpDate, requestConditions, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Updates the properties of the specified Job.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobId"> The ID of the Job whose properties you want to update. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='UpdateJob(string,RequestContent,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual Response UpdateJob(string jobId, RequestContent content, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.UpdateJob");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateJobRequest(jobId, content, timeOut, ocpDate, requestConditions, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Updates the properties of the specified Job. </summary>
        /// <param name="jobId"> The ID of the Job whose properties you want to update. </param>
        /// <param name="body"> A job with updated properties. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// This fully replaces all the updatable properties of the Job. For example, if
        /// the Job has constraints associated with it and if constraints is not specified
        /// with this request, then the Batch service will remove the existing constraints.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='ReplaceJobAsync(string,BatchJob,int?,DateTimeOffset?,RequestConditions,CancellationToken)']/*" />
        public virtual async Task<Response> ReplaceJobAsync(string jobId, BatchJob body, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNull(body, nameof(body));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = body.ToRequestContent();
            Response response = await ReplaceJobAsync(jobId, content, timeOut, ocpDate, requestConditions, context).ConfigureAwait(false);
            return response;
        }

        /// <summary> Updates the properties of the specified Job. </summary>
        /// <param name="jobId"> The ID of the Job whose properties you want to update. </param>
        /// <param name="body"> A job with updated properties. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// This fully replaces all the updatable properties of the Job. For example, if
        /// the Job has constraints associated with it and if constraints is not specified
        /// with this request, then the Batch service will remove the existing constraints.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='ReplaceJob(string,BatchJob,int?,DateTimeOffset?,RequestConditions,CancellationToken)']/*" />
        public virtual Response ReplaceJob(string jobId, BatchJob body, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNull(body, nameof(body));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = body.ToRequestContent();
            Response response = ReplaceJob(jobId, content, timeOut, ocpDate, requestConditions, context);
            return response;
        }

        /// <summary>
        /// [Protocol Method] Updates the properties of the specified Job.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="ReplaceJobAsync(string,BatchJob,int?,DateTimeOffset?,RequestConditions,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobId"> The ID of the Job whose properties you want to update. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='ReplaceJobAsync(string,RequestContent,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual async Task<Response> ReplaceJobAsync(string jobId, RequestContent content, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.ReplaceJob");
            scope.Start();
            try
            {
                using HttpMessage message = CreateReplaceJobRequest(jobId, content, timeOut, ocpDate, requestConditions, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Updates the properties of the specified Job.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="ReplaceJob(string,BatchJob,int?,DateTimeOffset?,RequestConditions,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobId"> The ID of the Job whose properties you want to update. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='ReplaceJob(string,RequestContent,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual Response ReplaceJob(string jobId, RequestContent content, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.ReplaceJob");
            scope.Start();
            try
            {
                using HttpMessage message = CreateReplaceJobRequest(jobId, content, timeOut, ocpDate, requestConditions, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Disables the specified Job, preventing new Tasks from running. </summary>
        /// <param name="jobId"> The ID of the Job to disable. </param>
        /// <param name="body"> The options to use for disabling the Job. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// The Batch Service immediately moves the Job to the disabling state. Batch then
        /// uses the disableTasks parameter to determine what to do with the currently
        /// running Tasks of the Job. The Job remains in the disabling state until the
        /// disable operation is completed and all Tasks have been dealt with according to
        /// the disableTasks option; the Job then moves to the disabled state. No new Tasks
        /// are started under the Job until it moves back to active state. If you try to
        /// disable a Job that is in any state other than active, disabling, or disabled,
        /// the request fails with status code 409.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='DisableJobAsync(string,BatchJobDisableOptions,int?,DateTimeOffset?,RequestConditions,CancellationToken)']/*" />
        public virtual async Task<Response> DisableJobAsync(string jobId, BatchJobDisableOptions body, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNull(body, nameof(body));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = body.ToRequestContent();
            Response response = await DisableJobAsync(jobId, content, timeOut, ocpDate, requestConditions, context).ConfigureAwait(false);
            return response;
        }

        /// <summary> Disables the specified Job, preventing new Tasks from running. </summary>
        /// <param name="jobId"> The ID of the Job to disable. </param>
        /// <param name="body"> The options to use for disabling the Job. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// The Batch Service immediately moves the Job to the disabling state. Batch then
        /// uses the disableTasks parameter to determine what to do with the currently
        /// running Tasks of the Job. The Job remains in the disabling state until the
        /// disable operation is completed and all Tasks have been dealt with according to
        /// the disableTasks option; the Job then moves to the disabled state. No new Tasks
        /// are started under the Job until it moves back to active state. If you try to
        /// disable a Job that is in any state other than active, disabling, or disabled,
        /// the request fails with status code 409.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='DisableJob(string,BatchJobDisableOptions,int?,DateTimeOffset?,RequestConditions,CancellationToken)']/*" />
        public virtual Response DisableJob(string jobId, BatchJobDisableOptions body, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNull(body, nameof(body));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = body.ToRequestContent();
            Response response = DisableJob(jobId, content, timeOut, ocpDate, requestConditions, context);
            return response;
        }

        /// <summary>
        /// [Protocol Method] Disables the specified Job, preventing new Tasks from running.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="DisableJobAsync(string,BatchJobDisableOptions,int?,DateTimeOffset?,RequestConditions,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobId"> The ID of the Job to disable. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='DisableJobAsync(string,RequestContent,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual async Task<Response> DisableJobAsync(string jobId, RequestContent content, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.DisableJob");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDisableJobRequest(jobId, content, timeOut, ocpDate, requestConditions, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Disables the specified Job, preventing new Tasks from running.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="DisableJob(string,BatchJobDisableOptions,int?,DateTimeOffset?,RequestConditions,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobId"> The ID of the Job to disable. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='DisableJob(string,RequestContent,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual Response DisableJob(string jobId, RequestContent content, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.DisableJob");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDisableJobRequest(jobId, content, timeOut, ocpDate, requestConditions, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Enables the specified Job, allowing new Tasks to run.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobId"> The ID of the Job to enable. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='EnableJobAsync(string,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual async Task<Response> EnableJobAsync(string jobId, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.EnableJob");
            scope.Start();
            try
            {
                using HttpMessage message = CreateEnableJobRequest(jobId, timeOut, ocpDate, requestConditions, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Enables the specified Job, allowing new Tasks to run.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobId"> The ID of the Job to enable. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='EnableJob(string,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual Response EnableJob(string jobId, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.EnableJob");
            scope.Start();
            try
            {
                using HttpMessage message = CreateEnableJobRequest(jobId, timeOut, ocpDate, requestConditions, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Terminates the specified Job, marking it as completed. </summary>
        /// <param name="jobId"> The ID of the Job to terminate. </param>
        /// <param name="body"> The options to use for terminating the Job. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// When a Terminate Job request is received, the Batch service sets the Job to the
        /// terminating state. The Batch service then terminates any running Tasks
        /// associated with the Job and runs any required Job release Tasks. Then the Job
        /// moves into the completed state. If there are any Tasks in the Job in the active
        /// state, they will remain in the active state. Once a Job is terminated, new
        /// Tasks cannot be added and any remaining active Tasks will not be scheduled.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='TerminateJobAsync(string,BatchJobTerminateOptions,int?,DateTimeOffset?,RequestConditions,CancellationToken)']/*" />
        public virtual async Task<Response> TerminateJobAsync(string jobId, BatchJobTerminateOptions body = null, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = body?.ToRequestContent();
            Response response = await TerminateJobAsync(jobId, content, timeOut, ocpDate, requestConditions, context).ConfigureAwait(false);
            return response;
        }

        /// <summary> Terminates the specified Job, marking it as completed. </summary>
        /// <param name="jobId"> The ID of the Job to terminate. </param>
        /// <param name="body"> The options to use for terminating the Job. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// When a Terminate Job request is received, the Batch service sets the Job to the
        /// terminating state. The Batch service then terminates any running Tasks
        /// associated with the Job and runs any required Job release Tasks. Then the Job
        /// moves into the completed state. If there are any Tasks in the Job in the active
        /// state, they will remain in the active state. Once a Job is terminated, new
        /// Tasks cannot be added and any remaining active Tasks will not be scheduled.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='TerminateJob(string,BatchJobTerminateOptions,int?,DateTimeOffset?,RequestConditions,CancellationToken)']/*" />
        public virtual Response TerminateJob(string jobId, BatchJobTerminateOptions body = null, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = body?.ToRequestContent();
            Response response = TerminateJob(jobId, content, timeOut, ocpDate, requestConditions, context);
            return response;
        }

        /// <summary>
        /// [Protocol Method] Terminates the specified Job, marking it as completed.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="TerminateJobAsync(string,BatchJobTerminateOptions,int?,DateTimeOffset?,RequestConditions,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobId"> The ID of the Job to terminate. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='TerminateJobAsync(string,RequestContent,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual async Task<Response> TerminateJobAsync(string jobId, RequestContent content, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.TerminateJob");
            scope.Start();
            try
            {
                using HttpMessage message = CreateTerminateJobRequest(jobId, content, timeOut, ocpDate, requestConditions, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Terminates the specified Job, marking it as completed.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="TerminateJob(string,BatchJobTerminateOptions,int?,DateTimeOffset?,RequestConditions,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobId"> The ID of the Job to terminate. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='TerminateJob(string,RequestContent,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual Response TerminateJob(string jobId, RequestContent content, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.TerminateJob");
            scope.Start();
            try
            {
                using HttpMessage message = CreateTerminateJobRequest(jobId, content, timeOut, ocpDate, requestConditions, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Creates a Job to the specified Account. </summary>
        /// <param name="body"> The Job to be created. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="body"/> is null. </exception>
        /// <remarks>
        /// The Batch service supports two ways to control the work done as part of a Job.
        /// In the first approach, the user specifies a Job Manager Task. The Batch service
        /// launches this Task when it is ready to start the Job. The Job Manager Task
        /// controls all other Tasks that run under this Job, by using the Task APIs. In
        /// the second approach, the user directly controls the execution of Tasks under an
        /// active Job, by using the Task APIs. Also note: when naming Jobs, avoid
        /// including sensitive information such as user names or secret project names.
        /// This information may appear in telemetry logs accessible to Microsoft Support
        /// engineers.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='CreateJobAsync(BatchJobCreateOptions,int?,DateTimeOffset?,CancellationToken)']/*" />
        public virtual async Task<Response> CreateJobAsync(BatchJobCreateOptions body, int? timeOut = null, DateTimeOffset? ocpDate = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(body, nameof(body));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = body.ToRequestContent();
            Response response = await CreateJobAsync(content, timeOut, ocpDate, context).ConfigureAwait(false);
            return response;
        }

        /// <summary> Creates a Job to the specified Account. </summary>
        /// <param name="body"> The Job to be created. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="body"/> is null. </exception>
        /// <remarks>
        /// The Batch service supports two ways to control the work done as part of a Job.
        /// In the first approach, the user specifies a Job Manager Task. The Batch service
        /// launches this Task when it is ready to start the Job. The Job Manager Task
        /// controls all other Tasks that run under this Job, by using the Task APIs. In
        /// the second approach, the user directly controls the execution of Tasks under an
        /// active Job, by using the Task APIs. Also note: when naming Jobs, avoid
        /// including sensitive information such as user names or secret project names.
        /// This information may appear in telemetry logs accessible to Microsoft Support
        /// engineers.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='CreateJob(BatchJobCreateOptions,int?,DateTimeOffset?,CancellationToken)']/*" />
        public virtual Response CreateJob(BatchJobCreateOptions body, int? timeOut = null, DateTimeOffset? ocpDate = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(body, nameof(body));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = body.ToRequestContent();
            Response response = CreateJob(content, timeOut, ocpDate, context);
            return response;
        }

        /// <summary>
        /// [Protocol Method] Creates a Job to the specified Account.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateJobAsync(BatchJobCreateOptions,int?,DateTimeOffset?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='CreateJobAsync(RequestContent,int?,DateTimeOffset?,RequestContext)']/*" />
        public virtual async Task<Response> CreateJobAsync(RequestContent content, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.CreateJob");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateJobRequest(content, timeOut, ocpDate, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Creates a Job to the specified Account.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateJob(BatchJobCreateOptions,int?,DateTimeOffset?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='CreateJob(RequestContent,int?,DateTimeOffset?,RequestContext)']/*" />
        public virtual Response CreateJob(RequestContent content, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.CreateJob");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateJobRequest(content, timeOut, ocpDate, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Lists all of the Jobs in the specified Account. </summary>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-jobs.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="expand"> An OData $expand clause. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetJobsAsync(int?,DateTimeOffset?,int?,string,IEnumerable{string},IEnumerable{string},CancellationToken)']/*" />
        public virtual async Task<Response<BatchJobListResult>> GetJobsAsync(int? maxresults = null, DateTimeOffset? ocpDate = null, int? timeOut = null, string filter = null, IEnumerable<string> select = null, IEnumerable<string> expand = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetJobsAsync(maxresults, ocpDate, timeOut, filter, select, expand, context).ConfigureAwait(false);
            return Response.FromValue(BatchJobListResult.FromResponse(response), response);
        }

        /// <summary> Lists all of the Jobs in the specified Account. </summary>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-jobs.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="expand"> An OData $expand clause. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetJobs(int?,DateTimeOffset?,int?,string,IEnumerable{string},IEnumerable{string},CancellationToken)']/*" />
        public virtual Response<BatchJobListResult> GetJobs(int? maxresults = null, DateTimeOffset? ocpDate = null, int? timeOut = null, string filter = null, IEnumerable<string> select = null, IEnumerable<string> expand = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetJobs(maxresults, ocpDate, timeOut, filter, select, expand, context);
            return Response.FromValue(BatchJobListResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Lists all of the Jobs in the specified Account.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetJobsAsync(int?,DateTimeOffset?,int?,string,IEnumerable{string},IEnumerable{string},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-jobs.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="expand"> An OData $expand clause. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetJobsAsync(int?,DateTimeOffset?,int?,string,IEnumerable{string},IEnumerable{string},RequestContext)']/*" />
        public virtual async Task<Response> GetJobsAsync(int? maxresults, DateTimeOffset? ocpDate, int? timeOut, string filter, IEnumerable<string> select, IEnumerable<string> expand, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetJobs");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetJobsRequest(maxresults, ocpDate, timeOut, filter, select, expand, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Lists all of the Jobs in the specified Account.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetJobs(int?,DateTimeOffset?,int?,string,IEnumerable{string},IEnumerable{string},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-jobs.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="expand"> An OData $expand clause. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetJobs(int?,DateTimeOffset?,int?,string,IEnumerable{string},IEnumerable{string},RequestContext)']/*" />
        public virtual Response GetJobs(int? maxresults, DateTimeOffset? ocpDate, int? timeOut, string filter, IEnumerable<string> select, IEnumerable<string> expand, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetJobs");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetJobsRequest(maxresults, ocpDate, timeOut, filter, select, expand, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Lists the Jobs that have been created under the specified Job Schedule. </summary>
        /// <param name="jobScheduleId"> The ID of the Job Schedule from which you want to get a list of Jobs. </param>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-jobs-in-a-job-schedule.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="expand"> An OData $expand clause. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobScheduleId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobScheduleId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetJobsFromSchedulesAsync(string,int?,DateTimeOffset?,int?,string,IEnumerable{string},IEnumerable{string},CancellationToken)']/*" />
        public virtual async Task<Response<BatchJobListResult>> GetJobsFromSchedulesAsync(string jobScheduleId, int? maxresults = null, DateTimeOffset? ocpDate = null, int? timeOut = null, string filter = null, IEnumerable<string> select = null, IEnumerable<string> expand = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(jobScheduleId, nameof(jobScheduleId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetJobsFromSchedulesAsync(jobScheduleId, maxresults, ocpDate, timeOut, filter, select, expand, context).ConfigureAwait(false);
            return Response.FromValue(BatchJobListResult.FromResponse(response), response);
        }

        /// <summary> Lists the Jobs that have been created under the specified Job Schedule. </summary>
        /// <param name="jobScheduleId"> The ID of the Job Schedule from which you want to get a list of Jobs. </param>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-jobs-in-a-job-schedule.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="expand"> An OData $expand clause. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobScheduleId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobScheduleId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetJobsFromSchedules(string,int?,DateTimeOffset?,int?,string,IEnumerable{string},IEnumerable{string},CancellationToken)']/*" />
        public virtual Response<BatchJobListResult> GetJobsFromSchedules(string jobScheduleId, int? maxresults = null, DateTimeOffset? ocpDate = null, int? timeOut = null, string filter = null, IEnumerable<string> select = null, IEnumerable<string> expand = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(jobScheduleId, nameof(jobScheduleId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetJobsFromSchedules(jobScheduleId, maxresults, ocpDate, timeOut, filter, select, expand, context);
            return Response.FromValue(BatchJobListResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Lists the Jobs that have been created under the specified Job Schedule.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetJobsFromSchedulesAsync(string,int?,DateTimeOffset?,int?,string,IEnumerable{string},IEnumerable{string},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobScheduleId"> The ID of the Job Schedule from which you want to get a list of Jobs. </param>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-jobs-in-a-job-schedule.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="expand"> An OData $expand clause. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobScheduleId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobScheduleId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetJobsFromSchedulesAsync(string,int?,DateTimeOffset?,int?,string,IEnumerable{string},IEnumerable{string},RequestContext)']/*" />
        public virtual async Task<Response> GetJobsFromSchedulesAsync(string jobScheduleId, int? maxresults, DateTimeOffset? ocpDate, int? timeOut, string filter, IEnumerable<string> select, IEnumerable<string> expand, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(jobScheduleId, nameof(jobScheduleId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetJobsFromSchedules");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetJobsFromSchedulesRequest(jobScheduleId, maxresults, ocpDate, timeOut, filter, select, expand, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Lists the Jobs that have been created under the specified Job Schedule.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetJobsFromSchedules(string,int?,DateTimeOffset?,int?,string,IEnumerable{string},IEnumerable{string},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobScheduleId"> The ID of the Job Schedule from which you want to get a list of Jobs. </param>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-jobs-in-a-job-schedule.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="expand"> An OData $expand clause. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobScheduleId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobScheduleId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetJobsFromSchedules(string,int?,DateTimeOffset?,int?,string,IEnumerable{string},IEnumerable{string},RequestContext)']/*" />
        public virtual Response GetJobsFromSchedules(string jobScheduleId, int? maxresults, DateTimeOffset? ocpDate, int? timeOut, string filter, IEnumerable<string> select, IEnumerable<string> expand, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(jobScheduleId, nameof(jobScheduleId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetJobsFromSchedules");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetJobsFromSchedulesRequest(jobScheduleId, maxresults, ocpDate, timeOut, filter, select, expand, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Lists the execution status of the Job Preparation and Job Release Task for the
        /// specified Job across the Compute Nodes where the Job has run.
        /// </summary>
        /// <param name="jobId"> The ID of the Job. </param>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-job-preparation-and-release-status.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// This API returns the Job Preparation and Job Release Task status on all Compute
        /// Nodes that have run the Job Preparation or Job Release Task. This includes
        /// Compute Nodes which have since been removed from the Pool. If this API is
        /// invoked on a Job which has no Job Preparation or Job Release Task, the Batch
        /// service returns HTTP status code 409 (Conflict) with an error code of
        /// JobPreparationTaskNotSpecified.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetJobPreparationAndReleaseTaskStatusesAsync(string,int?,DateTimeOffset?,int?,string,IEnumerable{string},CancellationToken)']/*" />
        public virtual async Task<Response<BatchJobListPreparationAndReleaseTaskStatusResult>> GetJobPreparationAndReleaseTaskStatusesAsync(string jobId, int? maxresults = null, DateTimeOffset? ocpDate = null, int? timeOut = null, string filter = null, IEnumerable<string> select = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetJobPreparationAndReleaseTaskStatusesAsync(jobId, maxresults, ocpDate, timeOut, filter, select, context).ConfigureAwait(false);
            return Response.FromValue(BatchJobListPreparationAndReleaseTaskStatusResult.FromResponse(response), response);
        }

        /// <summary>
        /// Lists the execution status of the Job Preparation and Job Release Task for the
        /// specified Job across the Compute Nodes where the Job has run.
        /// </summary>
        /// <param name="jobId"> The ID of the Job. </param>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-job-preparation-and-release-status.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// This API returns the Job Preparation and Job Release Task status on all Compute
        /// Nodes that have run the Job Preparation or Job Release Task. This includes
        /// Compute Nodes which have since been removed from the Pool. If this API is
        /// invoked on a Job which has no Job Preparation or Job Release Task, the Batch
        /// service returns HTTP status code 409 (Conflict) with an error code of
        /// JobPreparationTaskNotSpecified.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetJobPreparationAndReleaseTaskStatuses(string,int?,DateTimeOffset?,int?,string,IEnumerable{string},CancellationToken)']/*" />
        public virtual Response<BatchJobListPreparationAndReleaseTaskStatusResult> GetJobPreparationAndReleaseTaskStatuses(string jobId, int? maxresults = null, DateTimeOffset? ocpDate = null, int? timeOut = null, string filter = null, IEnumerable<string> select = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetJobPreparationAndReleaseTaskStatuses(jobId, maxresults, ocpDate, timeOut, filter, select, context);
            return Response.FromValue(BatchJobListPreparationAndReleaseTaskStatusResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Lists the execution status of the Job Preparation and Job Release Task for the
        /// specified Job across the Compute Nodes where the Job has run.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetJobPreparationAndReleaseTaskStatusesAsync(string,int?,DateTimeOffset?,int?,string,IEnumerable{string},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobId"> The ID of the Job. </param>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-job-preparation-and-release-status.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetJobPreparationAndReleaseTaskStatusesAsync(string,int?,DateTimeOffset?,int?,string,IEnumerable{string},RequestContext)']/*" />
        public virtual async Task<Response> GetJobPreparationAndReleaseTaskStatusesAsync(string jobId, int? maxresults, DateTimeOffset? ocpDate, int? timeOut, string filter, IEnumerable<string> select, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetJobPreparationAndReleaseTaskStatuses");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetJobPreparationAndReleaseTaskStatusesRequest(jobId, maxresults, ocpDate, timeOut, filter, select, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Lists the execution status of the Job Preparation and Job Release Task for the
        /// specified Job across the Compute Nodes where the Job has run.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetJobPreparationAndReleaseTaskStatuses(string,int?,DateTimeOffset?,int?,string,IEnumerable{string},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobId"> The ID of the Job. </param>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-job-preparation-and-release-status.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetJobPreparationAndReleaseTaskStatuses(string,int?,DateTimeOffset?,int?,string,IEnumerable{string},RequestContext)']/*" />
        public virtual Response GetJobPreparationAndReleaseTaskStatuses(string jobId, int? maxresults, DateTimeOffset? ocpDate, int? timeOut, string filter, IEnumerable<string> select, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetJobPreparationAndReleaseTaskStatuses");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetJobPreparationAndReleaseTaskStatusesRequest(jobId, maxresults, ocpDate, timeOut, filter, select, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the Task counts for the specified Job. </summary>
        /// <param name="jobId"> The ID of the Job. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Task counts provide a count of the Tasks by active, running or completed Task
        /// state, and a count of Tasks which succeeded or failed. Tasks in the preparing
        /// state are counted as running. Note that the numbers returned may not always be
        /// up to date. If you need exact task counts, use a list query.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetJobTaskCountsAsync(string,int?,DateTimeOffset?,CancellationToken)']/*" />
        public virtual async Task<Response<TaskCountsResult>> GetJobTaskCountsAsync(string jobId, int? timeOut = null, DateTimeOffset? ocpDate = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetJobTaskCountsAsync(jobId, timeOut, ocpDate, context).ConfigureAwait(false);
            return Response.FromValue(TaskCountsResult.FromResponse(response), response);
        }

        /// <summary> Gets the Task counts for the specified Job. </summary>
        /// <param name="jobId"> The ID of the Job. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Task counts provide a count of the Tasks by active, running or completed Task
        /// state, and a count of Tasks which succeeded or failed. Tasks in the preparing
        /// state are counted as running. Note that the numbers returned may not always be
        /// up to date. If you need exact task counts, use a list query.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetJobTaskCounts(string,int?,DateTimeOffset?,CancellationToken)']/*" />
        public virtual Response<TaskCountsResult> GetJobTaskCounts(string jobId, int? timeOut = null, DateTimeOffset? ocpDate = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetJobTaskCounts(jobId, timeOut, ocpDate, context);
            return Response.FromValue(TaskCountsResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Gets the Task counts for the specified Job.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetJobTaskCountsAsync(string,int?,DateTimeOffset?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobId"> The ID of the Job. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetJobTaskCountsAsync(string,int?,DateTimeOffset?,RequestContext)']/*" />
        public virtual async Task<Response> GetJobTaskCountsAsync(string jobId, int? timeOut, DateTimeOffset? ocpDate, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetJobTaskCounts");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetJobTaskCountsRequest(jobId, timeOut, ocpDate, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Gets the Task counts for the specified Job.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetJobTaskCounts(string,int?,DateTimeOffset?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobId"> The ID of the Job. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetJobTaskCounts(string,int?,DateTimeOffset?,RequestContext)']/*" />
        public virtual Response GetJobTaskCounts(string jobId, int? timeOut, DateTimeOffset? ocpDate, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetJobTaskCounts");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetJobTaskCountsRequest(jobId, timeOut, ocpDate, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Creates a Certificate to the specified Account. </summary>
        /// <param name="body"> The Certificate to be created. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="body"/> is null. </exception>
        [Obsolete("Warning: This operation is deprecated and will be removed after February, 2024. Please use the [Azure KeyVault Extension](https://learn.microsoft.com/azure/batch/batch-certificate-migration-guide) instead.")]
        public virtual async Task<Response> CreateCertificateAsync(BatchCertificate body, int? timeOut = null, DateTimeOffset? ocpDate = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(body, nameof(body));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = body.ToRequestContent();
            Response response = await CreateCertificateAsync(content, timeOut, ocpDate, context).ConfigureAwait(false);
            return response;
        }

        /// <summary> Creates a Certificate to the specified Account. </summary>
        /// <param name="body"> The Certificate to be created. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="body"/> is null. </exception>
        [Obsolete("Warning: This operation is deprecated and will be removed after February, 2024. Please use the [Azure KeyVault Extension](https://learn.microsoft.com/azure/batch/batch-certificate-migration-guide) instead.")]
        public virtual Response CreateCertificate(BatchCertificate body, int? timeOut = null, DateTimeOffset? ocpDate = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(body, nameof(body));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = body.ToRequestContent();
            Response response = CreateCertificate(content, timeOut, ocpDate, context);
            return response;
        }

        /// <summary>
        /// [Protocol Method] Creates a Certificate to the specified Account.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateCertificateAsync(BatchCertificate,int?,DateTimeOffset?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        [Obsolete("Warning: This operation is deprecated and will be removed after February, 2024. Please use the [Azure KeyVault Extension](https://learn.microsoft.com/azure/batch/batch-certificate-migration-guide) instead.")]
        public virtual async Task<Response> CreateCertificateAsync(RequestContent content, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.CreateCertificate");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateCertificateRequest(content, timeOut, ocpDate, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Creates a Certificate to the specified Account.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateCertificate(BatchCertificate,int?,DateTimeOffset?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        [Obsolete("Warning: This operation is deprecated and will be removed after February, 2024. Please use the [Azure KeyVault Extension](https://learn.microsoft.com/azure/batch/batch-certificate-migration-guide) instead.")]
        public virtual Response CreateCertificate(RequestContent content, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.CreateCertificate");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateCertificateRequest(content, timeOut, ocpDate, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Lists all of the Certificates that have been added to the specified Account. </summary>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-certificates.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        [Obsolete("Warning: This operation is deprecated and will be removed after February, 2024. Please use the [Azure KeyVault Extension](https://learn.microsoft.com/azure/batch/batch-certificate-migration-guide) instead.")]
        public virtual async Task<Response<CertificateListResult>> GetCertificatesAsync(int? maxresults = null, DateTimeOffset? ocpDate = null, int? timeOut = null, string filter = null, IEnumerable<string> select = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetCertificatesAsync(maxresults, ocpDate, timeOut, filter, select, context).ConfigureAwait(false);
            return Response.FromValue(CertificateListResult.FromResponse(response), response);
        }

        /// <summary> Lists all of the Certificates that have been added to the specified Account. </summary>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-certificates.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        [Obsolete("Warning: This operation is deprecated and will be removed after February, 2024. Please use the [Azure KeyVault Extension](https://learn.microsoft.com/azure/batch/batch-certificate-migration-guide) instead.")]
        public virtual Response<CertificateListResult> GetCertificates(int? maxresults = null, DateTimeOffset? ocpDate = null, int? timeOut = null, string filter = null, IEnumerable<string> select = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetCertificates(maxresults, ocpDate, timeOut, filter, select, context);
            return Response.FromValue(CertificateListResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Lists all of the Certificates that have been added to the specified Account.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetCertificatesAsync(int?,DateTimeOffset?,int?,string,IEnumerable{string},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-certificates.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        [Obsolete("Warning: This operation is deprecated and will be removed after February, 2024. Please use the [Azure KeyVault Extension](https://learn.microsoft.com/azure/batch/batch-certificate-migration-guide) instead.")]
        public virtual async Task<Response> GetCertificatesAsync(int? maxresults, DateTimeOffset? ocpDate, int? timeOut, string filter, IEnumerable<string> select, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetCertificates");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetCertificatesRequest(maxresults, ocpDate, timeOut, filter, select, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Lists all of the Certificates that have been added to the specified Account.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetCertificates(int?,DateTimeOffset?,int?,string,IEnumerable{string},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-certificates.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        [Obsolete("Warning: This operation is deprecated and will be removed after February, 2024. Please use the [Azure KeyVault Extension](https://learn.microsoft.com/azure/batch/batch-certificate-migration-guide) instead.")]
        public virtual Response GetCertificates(int? maxresults, DateTimeOffset? ocpDate, int? timeOut, string filter, IEnumerable<string> select, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetCertificates");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetCertificatesRequest(maxresults, ocpDate, timeOut, filter, select, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Cancels a failed deletion of a Certificate from the specified Account.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="thumbprintAlgorithm"> The algorithm used to derive the thumbprint parameter. This must be sha1. </param>
        /// <param name="thumbprint"> The thumbprint of the Certificate being deleted. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="thumbprintAlgorithm"/> or <paramref name="thumbprint"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="thumbprintAlgorithm"/> or <paramref name="thumbprint"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        [Obsolete("Warning: This operation is deprecated and will be removed after February, 2024. Please use the [Azure KeyVault Extension](https://learn.microsoft.com/azure/batch/batch-certificate-migration-guide) instead.")]
        public virtual async Task<Response> CancelCertificateDeletionAsync(string thumbprintAlgorithm, string thumbprint, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(thumbprintAlgorithm, nameof(thumbprintAlgorithm));
            Argument.AssertNotNullOrEmpty(thumbprint, nameof(thumbprint));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.CancelCertificateDeletion");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCancelCertificateDeletionRequest(thumbprintAlgorithm, thumbprint, timeOut, ocpDate, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Cancels a failed deletion of a Certificate from the specified Account.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="thumbprintAlgorithm"> The algorithm used to derive the thumbprint parameter. This must be sha1. </param>
        /// <param name="thumbprint"> The thumbprint of the Certificate being deleted. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="thumbprintAlgorithm"/> or <paramref name="thumbprint"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="thumbprintAlgorithm"/> or <paramref name="thumbprint"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        [Obsolete("Warning: This operation is deprecated and will be removed after February, 2024. Please use the [Azure KeyVault Extension](https://learn.microsoft.com/azure/batch/batch-certificate-migration-guide) instead.")]
        public virtual Response CancelCertificateDeletion(string thumbprintAlgorithm, string thumbprint, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(thumbprintAlgorithm, nameof(thumbprintAlgorithm));
            Argument.AssertNotNullOrEmpty(thumbprint, nameof(thumbprint));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.CancelCertificateDeletion");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCancelCertificateDeletionRequest(thumbprintAlgorithm, thumbprint, timeOut, ocpDate, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Deletes a Certificate from the specified Account.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="thumbprintAlgorithm"> The algorithm used to derive the thumbprint parameter. This must be sha1. </param>
        /// <param name="thumbprint"> The thumbprint of the Certificate to be deleted. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="thumbprintAlgorithm"/> or <paramref name="thumbprint"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="thumbprintAlgorithm"/> or <paramref name="thumbprint"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        [Obsolete("Warning: This operation is deprecated and will be removed after February, 2024. Please use the [Azure KeyVault Extension](https://learn.microsoft.com/azure/batch/batch-certificate-migration-guide) instead.")]
        public virtual async Task<Response> DeleteCertificateAsync(string thumbprintAlgorithm, string thumbprint, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(thumbprintAlgorithm, nameof(thumbprintAlgorithm));
            Argument.AssertNotNullOrEmpty(thumbprint, nameof(thumbprint));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.DeleteCertificate");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteCertificateRequest(thumbprintAlgorithm, thumbprint, timeOut, ocpDate, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Deletes a Certificate from the specified Account.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="thumbprintAlgorithm"> The algorithm used to derive the thumbprint parameter. This must be sha1. </param>
        /// <param name="thumbprint"> The thumbprint of the Certificate to be deleted. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="thumbprintAlgorithm"/> or <paramref name="thumbprint"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="thumbprintAlgorithm"/> or <paramref name="thumbprint"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        [Obsolete("Warning: This operation is deprecated and will be removed after February, 2024. Please use the [Azure KeyVault Extension](https://learn.microsoft.com/azure/batch/batch-certificate-migration-guide) instead.")]
        public virtual Response DeleteCertificate(string thumbprintAlgorithm, string thumbprint, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(thumbprintAlgorithm, nameof(thumbprintAlgorithm));
            Argument.AssertNotNullOrEmpty(thumbprint, nameof(thumbprint));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.DeleteCertificate");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteCertificateRequest(thumbprintAlgorithm, thumbprint, timeOut, ocpDate, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets information about the specified Certificate. </summary>
        /// <param name="thumbprintAlgorithm"> The algorithm used to derive the thumbprint parameter. This must be sha1. </param>
        /// <param name="thumbprint"> The thumbprint of the Certificate to get. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="thumbprintAlgorithm"/> or <paramref name="thumbprint"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="thumbprintAlgorithm"/> or <paramref name="thumbprint"/> is an empty string, and was expected to be non-empty. </exception>
        [Obsolete("Warning: This operation is deprecated and will be removed after February, 2024. Please use the [Azure KeyVault Extension](https://learn.microsoft.com/azure/batch/batch-certificate-migration-guide) instead.")]
        public virtual async Task<Response<BatchCertificate>> GetCertificateAsync(string thumbprintAlgorithm, string thumbprint, int? timeOut = null, DateTimeOffset? ocpDate = null, IEnumerable<string> select = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(thumbprintAlgorithm, nameof(thumbprintAlgorithm));
            Argument.AssertNotNullOrEmpty(thumbprint, nameof(thumbprint));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetCertificateAsync(thumbprintAlgorithm, thumbprint, timeOut, ocpDate, select, context).ConfigureAwait(false);
            return Response.FromValue(BatchCertificate.FromResponse(response), response);
        }

        /// <summary> Gets information about the specified Certificate. </summary>
        /// <param name="thumbprintAlgorithm"> The algorithm used to derive the thumbprint parameter. This must be sha1. </param>
        /// <param name="thumbprint"> The thumbprint of the Certificate to get. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="thumbprintAlgorithm"/> or <paramref name="thumbprint"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="thumbprintAlgorithm"/> or <paramref name="thumbprint"/> is an empty string, and was expected to be non-empty. </exception>
        [Obsolete("Warning: This operation is deprecated and will be removed after February, 2024. Please use the [Azure KeyVault Extension](https://learn.microsoft.com/azure/batch/batch-certificate-migration-guide) instead.")]
        public virtual Response<BatchCertificate> GetCertificate(string thumbprintAlgorithm, string thumbprint, int? timeOut = null, DateTimeOffset? ocpDate = null, IEnumerable<string> select = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(thumbprintAlgorithm, nameof(thumbprintAlgorithm));
            Argument.AssertNotNullOrEmpty(thumbprint, nameof(thumbprint));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetCertificate(thumbprintAlgorithm, thumbprint, timeOut, ocpDate, select, context);
            return Response.FromValue(BatchCertificate.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Gets information about the specified Certificate.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetCertificateAsync(string,string,int?,DateTimeOffset?,IEnumerable{string},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="thumbprintAlgorithm"> The algorithm used to derive the thumbprint parameter. This must be sha1. </param>
        /// <param name="thumbprint"> The thumbprint of the Certificate to get. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="thumbprintAlgorithm"/> or <paramref name="thumbprint"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="thumbprintAlgorithm"/> or <paramref name="thumbprint"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        [Obsolete("Warning: This operation is deprecated and will be removed after February, 2024. Please use the [Azure KeyVault Extension](https://learn.microsoft.com/azure/batch/batch-certificate-migration-guide) instead.")]
        public virtual async Task<Response> GetCertificateAsync(string thumbprintAlgorithm, string thumbprint, int? timeOut, DateTimeOffset? ocpDate, IEnumerable<string> select, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(thumbprintAlgorithm, nameof(thumbprintAlgorithm));
            Argument.AssertNotNullOrEmpty(thumbprint, nameof(thumbprint));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetCertificate");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetCertificateRequest(thumbprintAlgorithm, thumbprint, timeOut, ocpDate, select, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Gets information about the specified Certificate.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetCertificate(string,string,int?,DateTimeOffset?,IEnumerable{string},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="thumbprintAlgorithm"> The algorithm used to derive the thumbprint parameter. This must be sha1. </param>
        /// <param name="thumbprint"> The thumbprint of the Certificate to get. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="thumbprintAlgorithm"/> or <paramref name="thumbprint"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="thumbprintAlgorithm"/> or <paramref name="thumbprint"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        [Obsolete("Warning: This operation is deprecated and will be removed after February, 2024. Please use the [Azure KeyVault Extension](https://learn.microsoft.com/azure/batch/batch-certificate-migration-guide) instead.")]
        public virtual Response GetCertificate(string thumbprintAlgorithm, string thumbprint, int? timeOut, DateTimeOffset? ocpDate, IEnumerable<string> select, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(thumbprintAlgorithm, nameof(thumbprintAlgorithm));
            Argument.AssertNotNullOrEmpty(thumbprint, nameof(thumbprint));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetCertificate");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetCertificateRequest(thumbprintAlgorithm, thumbprint, timeOut, ocpDate, select, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Checks the specified Job Schedule exists.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobScheduleId"> The ID of the Job Schedule which you want to check. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobScheduleId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobScheduleId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='JobScheduleExistsAsync(string,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual async Task<Response<bool>> JobScheduleExistsAsync(string jobScheduleId, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobScheduleId, nameof(jobScheduleId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.JobScheduleExists");
            scope.Start();
            try
            {
                using HttpMessage message = CreateJobScheduleExistsRequest(jobScheduleId, timeOut, ocpDate, requestConditions, context);
                return await _pipeline.ProcessHeadAsBoolMessageAsync(message, ClientDiagnostics, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Checks the specified Job Schedule exists.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobScheduleId"> The ID of the Job Schedule which you want to check. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobScheduleId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobScheduleId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='JobScheduleExists(string,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual Response<bool> JobScheduleExists(string jobScheduleId, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobScheduleId, nameof(jobScheduleId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.JobScheduleExists");
            scope.Start();
            try
            {
                using HttpMessage message = CreateJobScheduleExistsRequest(jobScheduleId, timeOut, ocpDate, requestConditions, context);
                return _pipeline.ProcessHeadAsBoolMessage(message, ClientDiagnostics, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Deletes a Job Schedule from the specified Account.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobScheduleId"> The ID of the Job Schedule to delete. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobScheduleId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobScheduleId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='DeleteJobScheduleAsync(string,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual async Task<Response> DeleteJobScheduleAsync(string jobScheduleId, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobScheduleId, nameof(jobScheduleId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.DeleteJobSchedule");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteJobScheduleRequest(jobScheduleId, timeOut, ocpDate, requestConditions, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Deletes a Job Schedule from the specified Account.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobScheduleId"> The ID of the Job Schedule to delete. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobScheduleId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobScheduleId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='DeleteJobSchedule(string,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual Response DeleteJobSchedule(string jobScheduleId, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobScheduleId, nameof(jobScheduleId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.DeleteJobSchedule");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteJobScheduleRequest(jobScheduleId, timeOut, ocpDate, requestConditions, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets information about the specified Job Schedule. </summary>
        /// <param name="jobScheduleId"> The ID of the Job Schedule to get. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="expand"> An OData $expand clause. </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobScheduleId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobScheduleId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetJobScheduleAsync(string,int?,DateTimeOffset?,IEnumerable{string},IEnumerable{string},RequestConditions,CancellationToken)']/*" />
        public virtual async Task<Response<BatchJobSchedule>> GetJobScheduleAsync(string jobScheduleId, int? timeOut = null, DateTimeOffset? ocpDate = null, IEnumerable<string> select = null, IEnumerable<string> expand = null, RequestConditions requestConditions = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(jobScheduleId, nameof(jobScheduleId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetJobScheduleAsync(jobScheduleId, timeOut, ocpDate, select, expand, requestConditions, context).ConfigureAwait(false);
            return Response.FromValue(BatchJobSchedule.FromResponse(response), response);
        }

        /// <summary> Gets information about the specified Job Schedule. </summary>
        /// <param name="jobScheduleId"> The ID of the Job Schedule to get. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="expand"> An OData $expand clause. </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobScheduleId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobScheduleId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetJobSchedule(string,int?,DateTimeOffset?,IEnumerable{string},IEnumerable{string},RequestConditions,CancellationToken)']/*" />
        public virtual Response<BatchJobSchedule> GetJobSchedule(string jobScheduleId, int? timeOut = null, DateTimeOffset? ocpDate = null, IEnumerable<string> select = null, IEnumerable<string> expand = null, RequestConditions requestConditions = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(jobScheduleId, nameof(jobScheduleId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetJobSchedule(jobScheduleId, timeOut, ocpDate, select, expand, requestConditions, context);
            return Response.FromValue(BatchJobSchedule.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Gets information about the specified Job Schedule.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetJobScheduleAsync(string,int?,DateTimeOffset?,IEnumerable{string},IEnumerable{string},RequestConditions,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobScheduleId"> The ID of the Job Schedule to get. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="expand"> An OData $expand clause. </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobScheduleId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobScheduleId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetJobScheduleAsync(string,int?,DateTimeOffset?,IEnumerable{string},IEnumerable{string},RequestConditions,RequestContext)']/*" />
        public virtual async Task<Response> GetJobScheduleAsync(string jobScheduleId, int? timeOut, DateTimeOffset? ocpDate, IEnumerable<string> select, IEnumerable<string> expand, RequestConditions requestConditions, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(jobScheduleId, nameof(jobScheduleId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetJobSchedule");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetJobScheduleRequest(jobScheduleId, timeOut, ocpDate, select, expand, requestConditions, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Gets information about the specified Job Schedule.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetJobSchedule(string,int?,DateTimeOffset?,IEnumerable{string},IEnumerable{string},RequestConditions,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobScheduleId"> The ID of the Job Schedule to get. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="expand"> An OData $expand clause. </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobScheduleId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobScheduleId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetJobSchedule(string,int?,DateTimeOffset?,IEnumerable{string},IEnumerable{string},RequestConditions,RequestContext)']/*" />
        public virtual Response GetJobSchedule(string jobScheduleId, int? timeOut, DateTimeOffset? ocpDate, IEnumerable<string> select, IEnumerable<string> expand, RequestConditions requestConditions, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(jobScheduleId, nameof(jobScheduleId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetJobSchedule");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetJobScheduleRequest(jobScheduleId, timeOut, ocpDate, select, expand, requestConditions, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Updates the properties of the specified Job Schedule.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobScheduleId"> The ID of the Job Schedule to update. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobScheduleId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobScheduleId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='UpdateJobScheduleAsync(string,RequestContent,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual async Task<Response> UpdateJobScheduleAsync(string jobScheduleId, RequestContent content, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobScheduleId, nameof(jobScheduleId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.UpdateJobSchedule");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateJobScheduleRequest(jobScheduleId, content, timeOut, ocpDate, requestConditions, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Updates the properties of the specified Job Schedule.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobScheduleId"> The ID of the Job Schedule to update. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobScheduleId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobScheduleId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='UpdateJobSchedule(string,RequestContent,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual Response UpdateJobSchedule(string jobScheduleId, RequestContent content, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobScheduleId, nameof(jobScheduleId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.UpdateJobSchedule");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateJobScheduleRequest(jobScheduleId, content, timeOut, ocpDate, requestConditions, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Updates the properties of the specified Job Schedule. </summary>
        /// <param name="jobScheduleId"> The ID of the Job Schedule to update. </param>
        /// <param name="body"> A Job Schedule with updated properties. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobScheduleId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobScheduleId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// This fully replaces all the updatable properties of the Job Schedule. For
        /// example, if the schedule property is not specified with this request, then the
        /// Batch service will remove the existing schedule. Changes to a Job Schedule only
        /// impact Jobs created by the schedule after the update has taken place; currently
        /// running Jobs are unaffected.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='ReplaceJobScheduleAsync(string,BatchJobSchedule,int?,DateTimeOffset?,RequestConditions,CancellationToken)']/*" />
        public virtual async Task<Response> ReplaceJobScheduleAsync(string jobScheduleId, BatchJobSchedule body, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(jobScheduleId, nameof(jobScheduleId));
            Argument.AssertNotNull(body, nameof(body));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = body.ToRequestContent();
            Response response = await ReplaceJobScheduleAsync(jobScheduleId, content, timeOut, ocpDate, requestConditions, context).ConfigureAwait(false);
            return response;
        }

        /// <summary> Updates the properties of the specified Job Schedule. </summary>
        /// <param name="jobScheduleId"> The ID of the Job Schedule to update. </param>
        /// <param name="body"> A Job Schedule with updated properties. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobScheduleId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobScheduleId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// This fully replaces all the updatable properties of the Job Schedule. For
        /// example, if the schedule property is not specified with this request, then the
        /// Batch service will remove the existing schedule. Changes to a Job Schedule only
        /// impact Jobs created by the schedule after the update has taken place; currently
        /// running Jobs are unaffected.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='ReplaceJobSchedule(string,BatchJobSchedule,int?,DateTimeOffset?,RequestConditions,CancellationToken)']/*" />
        public virtual Response ReplaceJobSchedule(string jobScheduleId, BatchJobSchedule body, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(jobScheduleId, nameof(jobScheduleId));
            Argument.AssertNotNull(body, nameof(body));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = body.ToRequestContent();
            Response response = ReplaceJobSchedule(jobScheduleId, content, timeOut, ocpDate, requestConditions, context);
            return response;
        }

        /// <summary>
        /// [Protocol Method] Updates the properties of the specified Job Schedule.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="ReplaceJobScheduleAsync(string,BatchJobSchedule,int?,DateTimeOffset?,RequestConditions,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobScheduleId"> The ID of the Job Schedule to update. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobScheduleId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobScheduleId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='ReplaceJobScheduleAsync(string,RequestContent,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual async Task<Response> ReplaceJobScheduleAsync(string jobScheduleId, RequestContent content, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobScheduleId, nameof(jobScheduleId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.ReplaceJobSchedule");
            scope.Start();
            try
            {
                using HttpMessage message = CreateReplaceJobScheduleRequest(jobScheduleId, content, timeOut, ocpDate, requestConditions, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Updates the properties of the specified Job Schedule.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="ReplaceJobSchedule(string,BatchJobSchedule,int?,DateTimeOffset?,RequestConditions,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobScheduleId"> The ID of the Job Schedule to update. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobScheduleId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobScheduleId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='ReplaceJobSchedule(string,RequestContent,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual Response ReplaceJobSchedule(string jobScheduleId, RequestContent content, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobScheduleId, nameof(jobScheduleId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.ReplaceJobSchedule");
            scope.Start();
            try
            {
                using HttpMessage message = CreateReplaceJobScheduleRequest(jobScheduleId, content, timeOut, ocpDate, requestConditions, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Disables a Job Schedule.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobScheduleId"> The ID of the Job Schedule to disable. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobScheduleId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobScheduleId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='DisableJobScheduleAsync(string,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual async Task<Response> DisableJobScheduleAsync(string jobScheduleId, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobScheduleId, nameof(jobScheduleId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.DisableJobSchedule");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDisableJobScheduleRequest(jobScheduleId, timeOut, ocpDate, requestConditions, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Disables a Job Schedule.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobScheduleId"> The ID of the Job Schedule to disable. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobScheduleId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobScheduleId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='DisableJobSchedule(string,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual Response DisableJobSchedule(string jobScheduleId, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobScheduleId, nameof(jobScheduleId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.DisableJobSchedule");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDisableJobScheduleRequest(jobScheduleId, timeOut, ocpDate, requestConditions, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Enables a Job Schedule.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobScheduleId"> The ID of the Job Schedule to enable. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobScheduleId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobScheduleId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='EnableJobScheduleAsync(string,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual async Task<Response> EnableJobScheduleAsync(string jobScheduleId, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobScheduleId, nameof(jobScheduleId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.EnableJobSchedule");
            scope.Start();
            try
            {
                using HttpMessage message = CreateEnableJobScheduleRequest(jobScheduleId, timeOut, ocpDate, requestConditions, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Enables a Job Schedule.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobScheduleId"> The ID of the Job Schedule to enable. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobScheduleId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobScheduleId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='EnableJobSchedule(string,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual Response EnableJobSchedule(string jobScheduleId, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobScheduleId, nameof(jobScheduleId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.EnableJobSchedule");
            scope.Start();
            try
            {
                using HttpMessage message = CreateEnableJobScheduleRequest(jobScheduleId, timeOut, ocpDate, requestConditions, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Terminates a Job Schedule.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobScheduleId"> The ID of the Job Schedule to terminates. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobScheduleId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobScheduleId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='TerminateJobScheduleAsync(string,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual async Task<Response> TerminateJobScheduleAsync(string jobScheduleId, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobScheduleId, nameof(jobScheduleId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.TerminateJobSchedule");
            scope.Start();
            try
            {
                using HttpMessage message = CreateTerminateJobScheduleRequest(jobScheduleId, timeOut, ocpDate, requestConditions, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Terminates a Job Schedule.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobScheduleId"> The ID of the Job Schedule to terminates. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobScheduleId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobScheduleId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='TerminateJobSchedule(string,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual Response TerminateJobSchedule(string jobScheduleId, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobScheduleId, nameof(jobScheduleId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.TerminateJobSchedule");
            scope.Start();
            try
            {
                using HttpMessage message = CreateTerminateJobScheduleRequest(jobScheduleId, timeOut, ocpDate, requestConditions, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Creates a Job Schedule to the specified Account. </summary>
        /// <param name="body"> The Job Schedule to be created. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="body"/> is null. </exception>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='CreateJobScheduleAsync(BatchJobScheduleCreateOptions,int?,DateTimeOffset?,CancellationToken)']/*" />
        public virtual async Task<Response> CreateJobScheduleAsync(BatchJobScheduleCreateOptions body, int? timeOut = null, DateTimeOffset? ocpDate = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(body, nameof(body));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = body.ToRequestContent();
            Response response = await CreateJobScheduleAsync(content, timeOut, ocpDate, context).ConfigureAwait(false);
            return response;
        }

        /// <summary> Creates a Job Schedule to the specified Account. </summary>
        /// <param name="body"> The Job Schedule to be created. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="body"/> is null. </exception>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='CreateJobSchedule(BatchJobScheduleCreateOptions,int?,DateTimeOffset?,CancellationToken)']/*" />
        public virtual Response CreateJobSchedule(BatchJobScheduleCreateOptions body, int? timeOut = null, DateTimeOffset? ocpDate = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNull(body, nameof(body));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = body.ToRequestContent();
            Response response = CreateJobSchedule(content, timeOut, ocpDate, context);
            return response;
        }

        /// <summary>
        /// [Protocol Method] Creates a Job Schedule to the specified Account.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateJobScheduleAsync(BatchJobScheduleCreateOptions,int?,DateTimeOffset?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='CreateJobScheduleAsync(RequestContent,int?,DateTimeOffset?,RequestContext)']/*" />
        public virtual async Task<Response> CreateJobScheduleAsync(RequestContent content, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.CreateJobSchedule");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateJobScheduleRequest(content, timeOut, ocpDate, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Creates a Job Schedule to the specified Account.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateJobSchedule(BatchJobScheduleCreateOptions,int?,DateTimeOffset?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='CreateJobSchedule(RequestContent,int?,DateTimeOffset?,RequestContext)']/*" />
        public virtual Response CreateJobSchedule(RequestContent content, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.CreateJobSchedule");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateJobScheduleRequest(content, timeOut, ocpDate, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Lists all of the Job Schedules in the specified Account. </summary>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-job-schedules.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="expand"> An OData $expand clause. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetJobSchedulesAsync(int?,DateTimeOffset?,int?,string,IEnumerable{string},IEnumerable{string},CancellationToken)']/*" />
        public virtual async Task<Response<BatchJobScheduleListResult>> GetJobSchedulesAsync(int? maxresults = null, DateTimeOffset? ocpDate = null, int? timeOut = null, string filter = null, IEnumerable<string> select = null, IEnumerable<string> expand = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetJobSchedulesAsync(maxresults, ocpDate, timeOut, filter, select, expand, context).ConfigureAwait(false);
            return Response.FromValue(BatchJobScheduleListResult.FromResponse(response), response);
        }

        /// <summary> Lists all of the Job Schedules in the specified Account. </summary>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-job-schedules.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="expand"> An OData $expand clause. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetJobSchedules(int?,DateTimeOffset?,int?,string,IEnumerable{string},IEnumerable{string},CancellationToken)']/*" />
        public virtual Response<BatchJobScheduleListResult> GetJobSchedules(int? maxresults = null, DateTimeOffset? ocpDate = null, int? timeOut = null, string filter = null, IEnumerable<string> select = null, IEnumerable<string> expand = null, CancellationToken cancellationToken = default)
        {
            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetJobSchedules(maxresults, ocpDate, timeOut, filter, select, expand, context);
            return Response.FromValue(BatchJobScheduleListResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Lists all of the Job Schedules in the specified Account.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetJobSchedulesAsync(int?,DateTimeOffset?,int?,string,IEnumerable{string},IEnumerable{string},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-job-schedules.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="expand"> An OData $expand clause. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetJobSchedulesAsync(int?,DateTimeOffset?,int?,string,IEnumerable{string},IEnumerable{string},RequestContext)']/*" />
        public virtual async Task<Response> GetJobSchedulesAsync(int? maxresults, DateTimeOffset? ocpDate, int? timeOut, string filter, IEnumerable<string> select, IEnumerable<string> expand, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetJobSchedules");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetJobSchedulesRequest(maxresults, ocpDate, timeOut, filter, select, expand, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Lists all of the Job Schedules in the specified Account.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetJobSchedules(int?,DateTimeOffset?,int?,string,IEnumerable{string},IEnumerable{string},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-job-schedules.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="expand"> An OData $expand clause. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetJobSchedules(int?,DateTimeOffset?,int?,string,IEnumerable{string},IEnumerable{string},RequestContext)']/*" />
        public virtual Response GetJobSchedules(int? maxresults, DateTimeOffset? ocpDate, int? timeOut, string filter, IEnumerable<string> select, IEnumerable<string> expand, RequestContext context)
        {
            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetJobSchedules");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetJobSchedulesRequest(maxresults, ocpDate, timeOut, filter, select, expand, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Creates a Task to the specified Job. </summary>
        /// <param name="jobId"> The ID of the Job to which the Task is to be created. </param>
        /// <param name="body"> The Task to be created. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// The maximum lifetime of a Task from addition to completion is 180 days. If a
        /// Task has not completed within 180 days of being added it will be terminated by
        /// the Batch service and left in whatever state it was in at that time.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='CreateTaskAsync(string,BatchTaskCreateOptions,int?,DateTimeOffset?,CancellationToken)']/*" />
        public virtual async Task<Response> CreateTaskAsync(string jobId, BatchTaskCreateOptions body, int? timeOut = null, DateTimeOffset? ocpDate = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNull(body, nameof(body));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = body.ToRequestContent();
            Response response = await CreateTaskAsync(jobId, content, timeOut, ocpDate, context).ConfigureAwait(false);
            return response;
        }

        /// <summary> Creates a Task to the specified Job. </summary>
        /// <param name="jobId"> The ID of the Job to which the Task is to be created. </param>
        /// <param name="body"> The Task to be created. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// The maximum lifetime of a Task from addition to completion is 180 days. If a
        /// Task has not completed within 180 days of being added it will be terminated by
        /// the Batch service and left in whatever state it was in at that time.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='CreateTask(string,BatchTaskCreateOptions,int?,DateTimeOffset?,CancellationToken)']/*" />
        public virtual Response CreateTask(string jobId, BatchTaskCreateOptions body, int? timeOut = null, DateTimeOffset? ocpDate = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNull(body, nameof(body));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = body.ToRequestContent();
            Response response = CreateTask(jobId, content, timeOut, ocpDate, context);
            return response;
        }

        /// <summary>
        /// [Protocol Method] Creates a Task to the specified Job.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateTaskAsync(string,BatchTaskCreateOptions,int?,DateTimeOffset?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobId"> The ID of the Job to which the Task is to be created. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='CreateTaskAsync(string,RequestContent,int?,DateTimeOffset?,RequestContext)']/*" />
        public virtual async Task<Response> CreateTaskAsync(string jobId, RequestContent content, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.CreateTask");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateTaskRequest(jobId, content, timeOut, ocpDate, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Creates a Task to the specified Job.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateTask(string,BatchTaskCreateOptions,int?,DateTimeOffset?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobId"> The ID of the Job to which the Task is to be created. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='CreateTask(string,RequestContent,int?,DateTimeOffset?,RequestContext)']/*" />
        public virtual Response CreateTask(string jobId, RequestContent content, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.CreateTask");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateTaskRequest(jobId, content, timeOut, ocpDate, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Lists all of the Tasks that are associated with the specified Job. </summary>
        /// <param name="jobId"> The ID of the Job. </param>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-tasks.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="expand"> An OData $expand clause. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// For multi-instance Tasks, information such as affinityId, executionInfo and
        /// nodeInfo refer to the primary Task. Use the list subtasks API to retrieve
        /// information about subtasks.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetTasksAsync(string,int?,DateTimeOffset?,int?,string,IEnumerable{string},IEnumerable{string},CancellationToken)']/*" />
        public virtual async Task<Response<BatchTaskListResult>> GetTasksAsync(string jobId, int? maxresults = null, DateTimeOffset? ocpDate = null, int? timeOut = null, string filter = null, IEnumerable<string> select = null, IEnumerable<string> expand = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetTasksAsync(jobId, maxresults, ocpDate, timeOut, filter, select, expand, context).ConfigureAwait(false);
            return Response.FromValue(BatchTaskListResult.FromResponse(response), response);
        }

        /// <summary> Lists all of the Tasks that are associated with the specified Job. </summary>
        /// <param name="jobId"> The ID of the Job. </param>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-tasks.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="expand"> An OData $expand clause. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// For multi-instance Tasks, information such as affinityId, executionInfo and
        /// nodeInfo refer to the primary Task. Use the list subtasks API to retrieve
        /// information about subtasks.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetTasks(string,int?,DateTimeOffset?,int?,string,IEnumerable{string},IEnumerable{string},CancellationToken)']/*" />
        public virtual Response<BatchTaskListResult> GetTasks(string jobId, int? maxresults = null, DateTimeOffset? ocpDate = null, int? timeOut = null, string filter = null, IEnumerable<string> select = null, IEnumerable<string> expand = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetTasks(jobId, maxresults, ocpDate, timeOut, filter, select, expand, context);
            return Response.FromValue(BatchTaskListResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Lists all of the Tasks that are associated with the specified Job.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetTasksAsync(string,int?,DateTimeOffset?,int?,string,IEnumerable{string},IEnumerable{string},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobId"> The ID of the Job. </param>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-tasks.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="expand"> An OData $expand clause. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetTasksAsync(string,int?,DateTimeOffset?,int?,string,IEnumerable{string},IEnumerable{string},RequestContext)']/*" />
        public virtual async Task<Response> GetTasksAsync(string jobId, int? maxresults, DateTimeOffset? ocpDate, int? timeOut, string filter, IEnumerable<string> select, IEnumerable<string> expand, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetTasks");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTasksRequest(jobId, maxresults, ocpDate, timeOut, filter, select, expand, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Lists all of the Tasks that are associated with the specified Job.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetTasks(string,int?,DateTimeOffset?,int?,string,IEnumerable{string},IEnumerable{string},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobId"> The ID of the Job. </param>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-tasks.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="expand"> An OData $expand clause. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetTasks(string,int?,DateTimeOffset?,int?,string,IEnumerable{string},IEnumerable{string},RequestContext)']/*" />
        public virtual Response GetTasks(string jobId, int? maxresults, DateTimeOffset? ocpDate, int? timeOut, string filter, IEnumerable<string> select, IEnumerable<string> expand, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetTasks");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTasksRequest(jobId, maxresults, ocpDate, timeOut, filter, select, expand, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Adds a collection of Tasks to the specified Job. </summary>
        /// <param name="jobId"> The ID of the Job to which the Task collection is to be added. </param>
        /// <param name="collection"> The Tasks to be added. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="collection"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Note that each Task must have a unique ID. The Batch service may not return the
        /// results for each Task in the same order the Tasks were submitted in this
        /// request. If the server times out or the connection is closed during the
        /// request, the request may have been partially or fully processed, or not at all.
        /// In such cases, the user should re-issue the request. Note that it is up to the
        /// user to correctly handle failures when re-issuing a request. For example, you
        /// should use the same Task IDs during a retry so that if the prior operation
        /// succeeded, the retry will not create extra Tasks unexpectedly. If the response
        /// contains any Tasks which failed to add, a client can retry the request. In a
        /// retry, it is most efficient to resubmit only Tasks that failed to add, and to
        /// omit Tasks that were successfully added on the first attempt. The maximum
        /// lifetime of a Task from addition to completion is 180 days. If a Task has not
        /// completed within 180 days of being added it will be terminated by the Batch
        /// service and left in whatever state it was in at that time.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='CreateTaskCollectionAsync(string,BatchTaskCollection,int?,DateTimeOffset?,CancellationToken)']/*" />
        public virtual async Task<Response<TaskAddCollectionResult>> CreateTaskCollectionAsync(string jobId, BatchTaskCollection collection, int? timeOut = null, DateTimeOffset? ocpDate = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNull(collection, nameof(collection));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = collection.ToRequestContent();
            Response response = await CreateTaskCollectionAsync(jobId, content, timeOut, ocpDate, context).ConfigureAwait(false);
            return Response.FromValue(TaskAddCollectionResult.FromResponse(response), response);
        }

        /// <summary> Adds a collection of Tasks to the specified Job. </summary>
        /// <param name="jobId"> The ID of the Job to which the Task collection is to be added. </param>
        /// <param name="collection"> The Tasks to be added. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="collection"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Note that each Task must have a unique ID. The Batch service may not return the
        /// results for each Task in the same order the Tasks were submitted in this
        /// request. If the server times out or the connection is closed during the
        /// request, the request may have been partially or fully processed, or not at all.
        /// In such cases, the user should re-issue the request. Note that it is up to the
        /// user to correctly handle failures when re-issuing a request. For example, you
        /// should use the same Task IDs during a retry so that if the prior operation
        /// succeeded, the retry will not create extra Tasks unexpectedly. If the response
        /// contains any Tasks which failed to add, a client can retry the request. In a
        /// retry, it is most efficient to resubmit only Tasks that failed to add, and to
        /// omit Tasks that were successfully added on the first attempt. The maximum
        /// lifetime of a Task from addition to completion is 180 days. If a Task has not
        /// completed within 180 days of being added it will be terminated by the Batch
        /// service and left in whatever state it was in at that time.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='CreateTaskCollection(string,BatchTaskCollection,int?,DateTimeOffset?,CancellationToken)']/*" />
        public virtual Response<TaskAddCollectionResult> CreateTaskCollection(string jobId, BatchTaskCollection collection, int? timeOut = null, DateTimeOffset? ocpDate = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNull(collection, nameof(collection));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = collection.ToRequestContent();
            Response response = CreateTaskCollection(jobId, content, timeOut, ocpDate, context);
            return Response.FromValue(TaskAddCollectionResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Adds a collection of Tasks to the specified Job.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateTaskCollectionAsync(string,BatchTaskCollection,int?,DateTimeOffset?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobId"> The ID of the Job to which the Task collection is to be added. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='CreateTaskCollectionAsync(string,RequestContent,int?,DateTimeOffset?,RequestContext)']/*" />
        public virtual async Task<Response> CreateTaskCollectionAsync(string jobId, RequestContent content, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.CreateTaskCollection");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateTaskCollectionRequest(jobId, content, timeOut, ocpDate, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Adds a collection of Tasks to the specified Job.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateTaskCollection(string,BatchTaskCollection,int?,DateTimeOffset?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobId"> The ID of the Job to which the Task collection is to be added. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='CreateTaskCollection(string,RequestContent,int?,DateTimeOffset?,RequestContext)']/*" />
        public virtual Response CreateTaskCollection(string jobId, RequestContent content, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.CreateTaskCollection");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateTaskCollectionRequest(jobId, content, timeOut, ocpDate, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Deletes a Task from the specified Job.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobId"> The ID of the Job from which to delete the Task. </param>
        /// <param name="taskId"> The ID of the Task to delete. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> or <paramref name="taskId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='DeleteTaskAsync(string,string,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual async Task<Response> DeleteTaskAsync(string jobId, string taskId, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNullOrEmpty(taskId, nameof(taskId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.DeleteTask");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteTaskRequest(jobId, taskId, timeOut, ocpDate, requestConditions, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Deletes a Task from the specified Job.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobId"> The ID of the Job from which to delete the Task. </param>
        /// <param name="taskId"> The ID of the Task to delete. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> or <paramref name="taskId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='DeleteTask(string,string,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual Response DeleteTask(string jobId, string taskId, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNullOrEmpty(taskId, nameof(taskId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.DeleteTask");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteTaskRequest(jobId, taskId, timeOut, ocpDate, requestConditions, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets information about the specified Task. </summary>
        /// <param name="jobId"> The ID of the Job that contains the Task. </param>
        /// <param name="taskId"> The ID of the Task to get information about. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="expand"> An OData $expand clause. </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> or <paramref name="taskId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// For multi-instance Tasks, information such as affinityId, executionInfo and
        /// nodeInfo refer to the primary Task. Use the list subtasks API to retrieve
        /// information about subtasks.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetTaskAsync(string,string,int?,DateTimeOffset?,IEnumerable{string},IEnumerable{string},RequestConditions,CancellationToken)']/*" />
        public virtual async Task<Response<BatchTask>> GetTaskAsync(string jobId, string taskId, int? timeOut = null, DateTimeOffset? ocpDate = null, IEnumerable<string> select = null, IEnumerable<string> expand = null, RequestConditions requestConditions = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNullOrEmpty(taskId, nameof(taskId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetTaskAsync(jobId, taskId, timeOut, ocpDate, select, expand, requestConditions, context).ConfigureAwait(false);
            return Response.FromValue(BatchTask.FromResponse(response), response);
        }

        /// <summary> Gets information about the specified Task. </summary>
        /// <param name="jobId"> The ID of the Job that contains the Task. </param>
        /// <param name="taskId"> The ID of the Task to get information about. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="expand"> An OData $expand clause. </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> or <paramref name="taskId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// For multi-instance Tasks, information such as affinityId, executionInfo and
        /// nodeInfo refer to the primary Task. Use the list subtasks API to retrieve
        /// information about subtasks.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetTask(string,string,int?,DateTimeOffset?,IEnumerable{string},IEnumerable{string},RequestConditions,CancellationToken)']/*" />
        public virtual Response<BatchTask> GetTask(string jobId, string taskId, int? timeOut = null, DateTimeOffset? ocpDate = null, IEnumerable<string> select = null, IEnumerable<string> expand = null, RequestConditions requestConditions = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNullOrEmpty(taskId, nameof(taskId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetTask(jobId, taskId, timeOut, ocpDate, select, expand, requestConditions, context);
            return Response.FromValue(BatchTask.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Gets information about the specified Task.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetTaskAsync(string,string,int?,DateTimeOffset?,IEnumerable{string},IEnumerable{string},RequestConditions,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobId"> The ID of the Job that contains the Task. </param>
        /// <param name="taskId"> The ID of the Task to get information about. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="expand"> An OData $expand clause. </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> or <paramref name="taskId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetTaskAsync(string,string,int?,DateTimeOffset?,IEnumerable{string},IEnumerable{string},RequestConditions,RequestContext)']/*" />
        public virtual async Task<Response> GetTaskAsync(string jobId, string taskId, int? timeOut, DateTimeOffset? ocpDate, IEnumerable<string> select, IEnumerable<string> expand, RequestConditions requestConditions, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNullOrEmpty(taskId, nameof(taskId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetTask");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTaskRequest(jobId, taskId, timeOut, ocpDate, select, expand, requestConditions, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Gets information about the specified Task.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetTask(string,string,int?,DateTimeOffset?,IEnumerable{string},IEnumerable{string},RequestConditions,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobId"> The ID of the Job that contains the Task. </param>
        /// <param name="taskId"> The ID of the Task to get information about. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="expand"> An OData $expand clause. </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> or <paramref name="taskId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetTask(string,string,int?,DateTimeOffset?,IEnumerable{string},IEnumerable{string},RequestConditions,RequestContext)']/*" />
        public virtual Response GetTask(string jobId, string taskId, int? timeOut, DateTimeOffset? ocpDate, IEnumerable<string> select, IEnumerable<string> expand, RequestConditions requestConditions, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNullOrEmpty(taskId, nameof(taskId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetTask");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTaskRequest(jobId, taskId, timeOut, ocpDate, select, expand, requestConditions, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Updates the properties of the specified Task. </summary>
        /// <param name="jobId"> The ID of the Job containing the Task. </param>
        /// <param name="taskId"> The ID of the Task to update. </param>
        /// <param name="body"> The Task to update. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/>, <paramref name="taskId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> or <paramref name="taskId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='ReplaceTaskAsync(string,string,BatchTask,int?,DateTimeOffset?,RequestConditions,CancellationToken)']/*" />
        public virtual async Task<Response> ReplaceTaskAsync(string jobId, string taskId, BatchTask body, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNullOrEmpty(taskId, nameof(taskId));
            Argument.AssertNotNull(body, nameof(body));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = body.ToRequestContent();
            Response response = await ReplaceTaskAsync(jobId, taskId, content, timeOut, ocpDate, requestConditions, context).ConfigureAwait(false);
            return response;
        }

        /// <summary> Updates the properties of the specified Task. </summary>
        /// <param name="jobId"> The ID of the Job containing the Task. </param>
        /// <param name="taskId"> The ID of the Task to update. </param>
        /// <param name="body"> The Task to update. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/>, <paramref name="taskId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> or <paramref name="taskId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='ReplaceTask(string,string,BatchTask,int?,DateTimeOffset?,RequestConditions,CancellationToken)']/*" />
        public virtual Response ReplaceTask(string jobId, string taskId, BatchTask body, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNullOrEmpty(taskId, nameof(taskId));
            Argument.AssertNotNull(body, nameof(body));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = body.ToRequestContent();
            Response response = ReplaceTask(jobId, taskId, content, timeOut, ocpDate, requestConditions, context);
            return response;
        }

        /// <summary>
        /// [Protocol Method] Updates the properties of the specified Task.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="ReplaceTaskAsync(string,string,BatchTask,int?,DateTimeOffset?,RequestConditions,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobId"> The ID of the Job containing the Task. </param>
        /// <param name="taskId"> The ID of the Task to update. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/>, <paramref name="taskId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> or <paramref name="taskId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='ReplaceTaskAsync(string,string,RequestContent,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual async Task<Response> ReplaceTaskAsync(string jobId, string taskId, RequestContent content, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNullOrEmpty(taskId, nameof(taskId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.ReplaceTask");
            scope.Start();
            try
            {
                using HttpMessage message = CreateReplaceTaskRequest(jobId, taskId, content, timeOut, ocpDate, requestConditions, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Updates the properties of the specified Task.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="ReplaceTask(string,string,BatchTask,int?,DateTimeOffset?,RequestConditions,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobId"> The ID of the Job containing the Task. </param>
        /// <param name="taskId"> The ID of the Task to update. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/>, <paramref name="taskId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> or <paramref name="taskId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='ReplaceTask(string,string,RequestContent,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual Response ReplaceTask(string jobId, string taskId, RequestContent content, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNullOrEmpty(taskId, nameof(taskId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.ReplaceTask");
            scope.Start();
            try
            {
                using HttpMessage message = CreateReplaceTaskRequest(jobId, taskId, content, timeOut, ocpDate, requestConditions, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Lists all of the subtasks that are associated with the specified multi-instance
        /// Task.
        /// </summary>
        /// <param name="jobId"> The ID of the Job. </param>
        /// <param name="taskId"> The ID of the Task. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> or <paramref name="taskId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> If the Task is not a multi-instance Task then this returns an empty collection. </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetSubTasksAsync(string,string,int?,DateTimeOffset?,IEnumerable{string},CancellationToken)']/*" />
        public virtual async Task<Response<BatchTaskListSubtasksResult>> GetSubTasksAsync(string jobId, string taskId, int? timeOut = null, DateTimeOffset? ocpDate = null, IEnumerable<string> select = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNullOrEmpty(taskId, nameof(taskId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetSubTasksAsync(jobId, taskId, timeOut, ocpDate, select, context).ConfigureAwait(false);
            return Response.FromValue(BatchTaskListSubtasksResult.FromResponse(response), response);
        }

        /// <summary>
        /// Lists all of the subtasks that are associated with the specified multi-instance
        /// Task.
        /// </summary>
        /// <param name="jobId"> The ID of the Job. </param>
        /// <param name="taskId"> The ID of the Task. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> or <paramref name="taskId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> If the Task is not a multi-instance Task then this returns an empty collection. </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetSubTasks(string,string,int?,DateTimeOffset?,IEnumerable{string},CancellationToken)']/*" />
        public virtual Response<BatchTaskListSubtasksResult> GetSubTasks(string jobId, string taskId, int? timeOut = null, DateTimeOffset? ocpDate = null, IEnumerable<string> select = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNullOrEmpty(taskId, nameof(taskId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetSubTasks(jobId, taskId, timeOut, ocpDate, select, context);
            return Response.FromValue(BatchTaskListSubtasksResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Lists all of the subtasks that are associated with the specified multi-instance
        /// Task.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetSubTasksAsync(string,string,int?,DateTimeOffset?,IEnumerable{string},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobId"> The ID of the Job. </param>
        /// <param name="taskId"> The ID of the Task. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> or <paramref name="taskId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetSubTasksAsync(string,string,int?,DateTimeOffset?,IEnumerable{string},RequestContext)']/*" />
        public virtual async Task<Response> GetSubTasksAsync(string jobId, string taskId, int? timeOut, DateTimeOffset? ocpDate, IEnumerable<string> select, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNullOrEmpty(taskId, nameof(taskId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetSubTasks");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetSubTasksRequest(jobId, taskId, timeOut, ocpDate, select, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Lists all of the subtasks that are associated with the specified multi-instance
        /// Task.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetSubTasks(string,string,int?,DateTimeOffset?,IEnumerable{string},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobId"> The ID of the Job. </param>
        /// <param name="taskId"> The ID of the Task. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> or <paramref name="taskId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetSubTasks(string,string,int?,DateTimeOffset?,IEnumerable{string},RequestContext)']/*" />
        public virtual Response GetSubTasks(string jobId, string taskId, int? timeOut, DateTimeOffset? ocpDate, IEnumerable<string> select, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNullOrEmpty(taskId, nameof(taskId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetSubTasks");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetSubTasksRequest(jobId, taskId, timeOut, ocpDate, select, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Terminates the specified Task.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobId"> The ID of the Job containing the Task. </param>
        /// <param name="taskId"> The ID of the Task to terminate. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> or <paramref name="taskId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='TerminateTaskAsync(string,string,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual async Task<Response> TerminateTaskAsync(string jobId, string taskId, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNullOrEmpty(taskId, nameof(taskId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.TerminateTask");
            scope.Start();
            try
            {
                using HttpMessage message = CreateTerminateTaskRequest(jobId, taskId, timeOut, ocpDate, requestConditions, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Terminates the specified Task.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobId"> The ID of the Job containing the Task. </param>
        /// <param name="taskId"> The ID of the Task to terminate. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> or <paramref name="taskId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='TerminateTask(string,string,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual Response TerminateTask(string jobId, string taskId, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNullOrEmpty(taskId, nameof(taskId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.TerminateTask");
            scope.Start();
            try
            {
                using HttpMessage message = CreateTerminateTaskRequest(jobId, taskId, timeOut, ocpDate, requestConditions, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Reactivates a Task, allowing it to run again even if its retry count has been
        /// exhausted.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobId"> The ID of the Job containing the Task. </param>
        /// <param name="taskId"> The ID of the Task to reactivate. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> or <paramref name="taskId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='ReactivateTaskAsync(string,string,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual async Task<Response> ReactivateTaskAsync(string jobId, string taskId, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNullOrEmpty(taskId, nameof(taskId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.ReactivateTask");
            scope.Start();
            try
            {
                using HttpMessage message = CreateReactivateTaskRequest(jobId, taskId, timeOut, ocpDate, requestConditions, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Reactivates a Task, allowing it to run again even if its retry count has been
        /// exhausted.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobId"> The ID of the Job containing the Task. </param>
        /// <param name="taskId"> The ID of the Task to reactivate. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> or <paramref name="taskId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='ReactivateTask(string,string,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual Response ReactivateTask(string jobId, string taskId, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNullOrEmpty(taskId, nameof(taskId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.ReactivateTask");
            scope.Start();
            try
            {
                using HttpMessage message = CreateReactivateTaskRequest(jobId, taskId, timeOut, ocpDate, requestConditions, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Deletes the specified Task file from the Compute Node where the Task ran.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobId"> The ID of the Job that contains the Task. </param>
        /// <param name="taskId"> The ID of the Task whose file you want to retrieve. </param>
        /// <param name="filePath"> The path to the Task file that you want to get the content of. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="recursive">
        /// Whether to delete children of a directory. If the filePath parameter represents
        /// a directory instead of a file, you can set recursive to true to delete the
        /// directory and all of the files and subdirectories in it. If recursive is false
        /// then the directory must be empty or deletion will fail.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/>, <paramref name="taskId"/> or <paramref name="filePath"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/>, <paramref name="taskId"/> or <paramref name="filePath"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='DeleteTaskFileAsync(string,string,string,int?,DateTimeOffset?,bool?,RequestContext)']/*" />
        public virtual async Task<Response> DeleteTaskFileAsync(string jobId, string taskId, string filePath, int? timeOut = null, DateTimeOffset? ocpDate = null, bool? recursive = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNullOrEmpty(taskId, nameof(taskId));
            Argument.AssertNotNullOrEmpty(filePath, nameof(filePath));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.DeleteTaskFile");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteTaskFileRequest(jobId, taskId, filePath, timeOut, ocpDate, recursive, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Deletes the specified Task file from the Compute Node where the Task ran.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobId"> The ID of the Job that contains the Task. </param>
        /// <param name="taskId"> The ID of the Task whose file you want to retrieve. </param>
        /// <param name="filePath"> The path to the Task file that you want to get the content of. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="recursive">
        /// Whether to delete children of a directory. If the filePath parameter represents
        /// a directory instead of a file, you can set recursive to true to delete the
        /// directory and all of the files and subdirectories in it. If recursive is false
        /// then the directory must be empty or deletion will fail.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/>, <paramref name="taskId"/> or <paramref name="filePath"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/>, <paramref name="taskId"/> or <paramref name="filePath"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='DeleteTaskFile(string,string,string,int?,DateTimeOffset?,bool?,RequestContext)']/*" />
        public virtual Response DeleteTaskFile(string jobId, string taskId, string filePath, int? timeOut = null, DateTimeOffset? ocpDate = null, bool? recursive = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNullOrEmpty(taskId, nameof(taskId));
            Argument.AssertNotNullOrEmpty(filePath, nameof(filePath));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.DeleteTaskFile");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteTaskFileRequest(jobId, taskId, filePath, timeOut, ocpDate, recursive, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Returns the content of the specified Task file. </summary>
        /// <param name="jobId"> The ID of the Job that contains the Task. </param>
        /// <param name="taskId"> The ID of the Task whose file you want to retrieve. </param>
        /// <param name="filePath"> The path to the Task file that you want to get the content of. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="ocpRange">
        /// The byte range to be retrieved. The default is to retrieve the entire file. The
        /// format is bytes=startRange-endRange.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/>, <paramref name="taskId"/> or <paramref name="filePath"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/>, <paramref name="taskId"/> or <paramref name="filePath"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetTaskFileAsync(string,string,string,int?,DateTimeOffset?,string,RequestConditions,CancellationToken)']/*" />
        public virtual async Task<Response<BinaryData>> GetTaskFileAsync(string jobId, string taskId, string filePath, int? timeOut = null, DateTimeOffset? ocpDate = null, string ocpRange = null, RequestConditions requestConditions = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNullOrEmpty(taskId, nameof(taskId));
            Argument.AssertNotNullOrEmpty(filePath, nameof(filePath));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetTaskFileAsync(jobId, taskId, filePath, timeOut, ocpDate, ocpRange, requestConditions, context).ConfigureAwait(false);
            return Response.FromValue(response.Content, response);
        }

        /// <summary> Returns the content of the specified Task file. </summary>
        /// <param name="jobId"> The ID of the Job that contains the Task. </param>
        /// <param name="taskId"> The ID of the Task whose file you want to retrieve. </param>
        /// <param name="filePath"> The path to the Task file that you want to get the content of. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="ocpRange">
        /// The byte range to be retrieved. The default is to retrieve the entire file. The
        /// format is bytes=startRange-endRange.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/>, <paramref name="taskId"/> or <paramref name="filePath"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/>, <paramref name="taskId"/> or <paramref name="filePath"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetTaskFile(string,string,string,int?,DateTimeOffset?,string,RequestConditions,CancellationToken)']/*" />
        public virtual Response<BinaryData> GetTaskFile(string jobId, string taskId, string filePath, int? timeOut = null, DateTimeOffset? ocpDate = null, string ocpRange = null, RequestConditions requestConditions = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNullOrEmpty(taskId, nameof(taskId));
            Argument.AssertNotNullOrEmpty(filePath, nameof(filePath));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetTaskFile(jobId, taskId, filePath, timeOut, ocpDate, ocpRange, requestConditions, context);
            return Response.FromValue(response.Content, response);
        }

        /// <summary>
        /// [Protocol Method] Returns the content of the specified Task file.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetTaskFileAsync(string,string,string,int?,DateTimeOffset?,string,RequestConditions,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobId"> The ID of the Job that contains the Task. </param>
        /// <param name="taskId"> The ID of the Task whose file you want to retrieve. </param>
        /// <param name="filePath"> The path to the Task file that you want to get the content of. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="ocpRange">
        /// The byte range to be retrieved. The default is to retrieve the entire file. The
        /// format is bytes=startRange-endRange.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/>, <paramref name="taskId"/> or <paramref name="filePath"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/>, <paramref name="taskId"/> or <paramref name="filePath"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetTaskFileAsync(string,string,string,int?,DateTimeOffset?,string,RequestConditions,RequestContext)']/*" />
        public virtual async Task<Response> GetTaskFileAsync(string jobId, string taskId, string filePath, int? timeOut, DateTimeOffset? ocpDate, string ocpRange, RequestConditions requestConditions, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNullOrEmpty(taskId, nameof(taskId));
            Argument.AssertNotNullOrEmpty(filePath, nameof(filePath));

            Argument.AssertNull(requestConditions.IfMatch, nameof(requestConditions), "Service does not support the If-Match header for this operation.");
            Argument.AssertNull(requestConditions.IfNoneMatch, nameof(requestConditions), "Service does not support the If-None-Match header for this operation.");

            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetTaskFile");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTaskFileRequest(jobId, taskId, filePath, timeOut, ocpDate, ocpRange, requestConditions, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Returns the content of the specified Task file.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetTaskFile(string,string,string,int?,DateTimeOffset?,string,RequestConditions,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobId"> The ID of the Job that contains the Task. </param>
        /// <param name="taskId"> The ID of the Task whose file you want to retrieve. </param>
        /// <param name="filePath"> The path to the Task file that you want to get the content of. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="ocpRange">
        /// The byte range to be retrieved. The default is to retrieve the entire file. The
        /// format is bytes=startRange-endRange.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/>, <paramref name="taskId"/> or <paramref name="filePath"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/>, <paramref name="taskId"/> or <paramref name="filePath"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetTaskFile(string,string,string,int?,DateTimeOffset?,string,RequestConditions,RequestContext)']/*" />
        public virtual Response GetTaskFile(string jobId, string taskId, string filePath, int? timeOut, DateTimeOffset? ocpDate, string ocpRange, RequestConditions requestConditions, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNullOrEmpty(taskId, nameof(taskId));
            Argument.AssertNotNullOrEmpty(filePath, nameof(filePath));

            Argument.AssertNull(requestConditions.IfMatch, nameof(requestConditions), "Service does not support the If-Match header for this operation.");
            Argument.AssertNull(requestConditions.IfNoneMatch, nameof(requestConditions), "Service does not support the If-None-Match header for this operation.");

            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetTaskFile");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTaskFileRequest(jobId, taskId, filePath, timeOut, ocpDate, ocpRange, requestConditions, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Gets the properties of the specified Task file.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobId"> The ID of the Job that contains the Task. </param>
        /// <param name="taskId"> The ID of the Task whose file you want to retrieve. </param>
        /// <param name="filePath"> The path to the Task file that you want to get the content of. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/>, <paramref name="taskId"/> or <paramref name="filePath"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/>, <paramref name="taskId"/> or <paramref name="filePath"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetTaskFilePropertiesAsync(string,string,string,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual async Task<Response<bool>> GetTaskFilePropertiesAsync(string jobId, string taskId, string filePath, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNullOrEmpty(taskId, nameof(taskId));
            Argument.AssertNotNullOrEmpty(filePath, nameof(filePath));

            Argument.AssertNull(requestConditions.IfMatch, nameof(requestConditions), "Service does not support the If-Match header for this operation.");
            Argument.AssertNull(requestConditions.IfNoneMatch, nameof(requestConditions), "Service does not support the If-None-Match header for this operation.");

            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetTaskFileProperties");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTaskFilePropertiesRequest(jobId, taskId, filePath, timeOut, ocpDate, requestConditions, context);
                return await _pipeline.ProcessHeadAsBoolMessageAsync(message, ClientDiagnostics, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Gets the properties of the specified Task file.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobId"> The ID of the Job that contains the Task. </param>
        /// <param name="taskId"> The ID of the Task whose file you want to retrieve. </param>
        /// <param name="filePath"> The path to the Task file that you want to get the content of. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/>, <paramref name="taskId"/> or <paramref name="filePath"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/>, <paramref name="taskId"/> or <paramref name="filePath"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetTaskFileProperties(string,string,string,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual Response<bool> GetTaskFileProperties(string jobId, string taskId, string filePath, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNullOrEmpty(taskId, nameof(taskId));
            Argument.AssertNotNullOrEmpty(filePath, nameof(filePath));

            Argument.AssertNull(requestConditions.IfMatch, nameof(requestConditions), "Service does not support the If-Match header for this operation.");
            Argument.AssertNull(requestConditions.IfNoneMatch, nameof(requestConditions), "Service does not support the If-None-Match header for this operation.");

            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetTaskFileProperties");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTaskFilePropertiesRequest(jobId, taskId, filePath, timeOut, ocpDate, requestConditions, context);
                return _pipeline.ProcessHeadAsBoolMessage(message, ClientDiagnostics, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Lists the files in a Task's directory on its Compute Node. </summary>
        /// <param name="jobId"> The ID of the Job that contains the Task. </param>
        /// <param name="taskId"> The ID of the Task whose files you want to list. </param>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-task-files.
        /// </param>
        /// <param name="recursive">
        /// Whether to list children of the Task directory. This parameter can be used in
        /// combination with the filter parameter to list specific type of files.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> or <paramref name="taskId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetTaskFilesAsync(string,string,int?,DateTimeOffset?,int?,string,bool?,CancellationToken)']/*" />
        public virtual async Task<Response<NodeFileListResult>> GetTaskFilesAsync(string jobId, string taskId, int? maxresults = null, DateTimeOffset? ocpDate = null, int? timeOut = null, string filter = null, bool? recursive = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNullOrEmpty(taskId, nameof(taskId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetTaskFilesAsync(jobId, taskId, maxresults, ocpDate, timeOut, filter, recursive, context).ConfigureAwait(false);
            return Response.FromValue(NodeFileListResult.FromResponse(response), response);
        }

        /// <summary> Lists the files in a Task's directory on its Compute Node. </summary>
        /// <param name="jobId"> The ID of the Job that contains the Task. </param>
        /// <param name="taskId"> The ID of the Task whose files you want to list. </param>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-task-files.
        /// </param>
        /// <param name="recursive">
        /// Whether to list children of the Task directory. This parameter can be used in
        /// combination with the filter parameter to list specific type of files.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> or <paramref name="taskId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetTaskFiles(string,string,int?,DateTimeOffset?,int?,string,bool?,CancellationToken)']/*" />
        public virtual Response<NodeFileListResult> GetTaskFiles(string jobId, string taskId, int? maxresults = null, DateTimeOffset? ocpDate = null, int? timeOut = null, string filter = null, bool? recursive = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNullOrEmpty(taskId, nameof(taskId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetTaskFiles(jobId, taskId, maxresults, ocpDate, timeOut, filter, recursive, context);
            return Response.FromValue(NodeFileListResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Lists the files in a Task's directory on its Compute Node.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetTaskFilesAsync(string,string,int?,DateTimeOffset?,int?,string,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobId"> The ID of the Job that contains the Task. </param>
        /// <param name="taskId"> The ID of the Task whose files you want to list. </param>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-task-files.
        /// </param>
        /// <param name="recursive">
        /// Whether to list children of the Task directory. This parameter can be used in
        /// combination with the filter parameter to list specific type of files.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> or <paramref name="taskId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetTaskFilesAsync(string,string,int?,DateTimeOffset?,int?,string,bool?,RequestContext)']/*" />
        public virtual async Task<Response> GetTaskFilesAsync(string jobId, string taskId, int? maxresults, DateTimeOffset? ocpDate, int? timeOut, string filter, bool? recursive, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNullOrEmpty(taskId, nameof(taskId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetTaskFiles");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTaskFilesRequest(jobId, taskId, maxresults, ocpDate, timeOut, filter, recursive, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Lists the files in a Task's directory on its Compute Node.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetTaskFiles(string,string,int?,DateTimeOffset?,int?,string,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="jobId"> The ID of the Job that contains the Task. </param>
        /// <param name="taskId"> The ID of the Task whose files you want to list. </param>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-task-files.
        /// </param>
        /// <param name="recursive">
        /// Whether to list children of the Task directory. This parameter can be used in
        /// combination with the filter parameter to list specific type of files.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="jobId"/> or <paramref name="taskId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="jobId"/> or <paramref name="taskId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetTaskFiles(string,string,int?,DateTimeOffset?,int?,string,bool?,RequestContext)']/*" />
        public virtual Response GetTaskFiles(string jobId, string taskId, int? maxresults, DateTimeOffset? ocpDate, int? timeOut, string filter, bool? recursive, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(jobId, nameof(jobId));
            Argument.AssertNotNullOrEmpty(taskId, nameof(taskId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetTaskFiles");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetTaskFilesRequest(jobId, taskId, maxresults, ocpDate, timeOut, filter, recursive, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Adds a user Account to the specified Compute Node. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the machine on which you want to create a user Account. </param>
        /// <param name="body"> The options to use for creating the user. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// You can add a user Account to a Compute Node only when it is in the idle or
        /// running state.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='CreateNodeUserAsync(string,string,BatchNodeUserCreateOptions,int?,DateTimeOffset?,CancellationToken)']/*" />
        public virtual async Task<Response> CreateNodeUserAsync(string poolId, string nodeId, BatchNodeUserCreateOptions body, int? timeOut = null, DateTimeOffset? ocpDate = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));
            Argument.AssertNotNull(body, nameof(body));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = body.ToRequestContent();
            Response response = await CreateNodeUserAsync(poolId, nodeId, content, timeOut, ocpDate, context).ConfigureAwait(false);
            return response;
        }

        /// <summary> Adds a user Account to the specified Compute Node. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the machine on which you want to create a user Account. </param>
        /// <param name="body"> The options to use for creating the user. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// You can add a user Account to a Compute Node only when it is in the idle or
        /// running state.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='CreateNodeUser(string,string,BatchNodeUserCreateOptions,int?,DateTimeOffset?,CancellationToken)']/*" />
        public virtual Response CreateNodeUser(string poolId, string nodeId, BatchNodeUserCreateOptions body, int? timeOut = null, DateTimeOffset? ocpDate = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));
            Argument.AssertNotNull(body, nameof(body));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = body.ToRequestContent();
            Response response = CreateNodeUser(poolId, nodeId, content, timeOut, ocpDate, context);
            return response;
        }

        /// <summary>
        /// [Protocol Method] Adds a user Account to the specified Compute Node.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateNodeUserAsync(string,string,BatchNodeUserCreateOptions,int?,DateTimeOffset?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the machine on which you want to create a user Account. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='CreateNodeUserAsync(string,string,RequestContent,int?,DateTimeOffset?,RequestContext)']/*" />
        public virtual async Task<Response> CreateNodeUserAsync(string poolId, string nodeId, RequestContent content, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.CreateNodeUser");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateNodeUserRequest(poolId, nodeId, content, timeOut, ocpDate, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Adds a user Account to the specified Compute Node.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateNodeUser(string,string,BatchNodeUserCreateOptions,int?,DateTimeOffset?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the machine on which you want to create a user Account. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='CreateNodeUser(string,string,RequestContent,int?,DateTimeOffset?,RequestContext)']/*" />
        public virtual Response CreateNodeUser(string poolId, string nodeId, RequestContent content, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.CreateNodeUser");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateNodeUserRequest(poolId, nodeId, content, timeOut, ocpDate, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Deletes a user Account from the specified Compute Node.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the machine on which you want to delete a user Account. </param>
        /// <param name="userName"> The name of the user Account to delete. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="userName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="userName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='DeleteNodeUserAsync(string,string,string,int?,DateTimeOffset?,RequestContext)']/*" />
        public virtual async Task<Response> DeleteNodeUserAsync(string poolId, string nodeId, string userName, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));
            Argument.AssertNotNullOrEmpty(userName, nameof(userName));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.DeleteNodeUser");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteNodeUserRequest(poolId, nodeId, userName, timeOut, ocpDate, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Deletes a user Account from the specified Compute Node.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the machine on which you want to delete a user Account. </param>
        /// <param name="userName"> The name of the user Account to delete. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="userName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="userName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='DeleteNodeUser(string,string,string,int?,DateTimeOffset?,RequestContext)']/*" />
        public virtual Response DeleteNodeUser(string poolId, string nodeId, string userName, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));
            Argument.AssertNotNullOrEmpty(userName, nameof(userName));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.DeleteNodeUser");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteNodeUserRequest(poolId, nodeId, userName, timeOut, ocpDate, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Updates the password and expiration time of a user Account on the specified Compute Node. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the machine on which you want to update a user Account. </param>
        /// <param name="userName"> The name of the user Account to update. </param>
        /// <param name="body"> The options to use for updating the user. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/>, <paramref name="nodeId"/>, <paramref name="userName"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="userName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// This operation replaces of all the updatable properties of the Account. For
        /// example, if the expiryTime element is not specified, the current value is
        /// replaced with the default value, not left unmodified. You can update a user
        /// Account on a Compute Node only when it is in the idle or running state.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='ReplaceNodeUserAsync(string,string,string,BatchNodeUserUpdateOptions,int?,DateTimeOffset?,CancellationToken)']/*" />
        public virtual async Task<Response> ReplaceNodeUserAsync(string poolId, string nodeId, string userName, BatchNodeUserUpdateOptions body, int? timeOut = null, DateTimeOffset? ocpDate = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));
            Argument.AssertNotNullOrEmpty(userName, nameof(userName));
            Argument.AssertNotNull(body, nameof(body));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = body.ToRequestContent();
            Response response = await ReplaceNodeUserAsync(poolId, nodeId, userName, content, timeOut, ocpDate, context).ConfigureAwait(false);
            return response;
        }

        /// <summary> Updates the password and expiration time of a user Account on the specified Compute Node. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the machine on which you want to update a user Account. </param>
        /// <param name="userName"> The name of the user Account to update. </param>
        /// <param name="body"> The options to use for updating the user. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/>, <paramref name="nodeId"/>, <paramref name="userName"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="userName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// This operation replaces of all the updatable properties of the Account. For
        /// example, if the expiryTime element is not specified, the current value is
        /// replaced with the default value, not left unmodified. You can update a user
        /// Account on a Compute Node only when it is in the idle or running state.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='ReplaceNodeUser(string,string,string,BatchNodeUserUpdateOptions,int?,DateTimeOffset?,CancellationToken)']/*" />
        public virtual Response ReplaceNodeUser(string poolId, string nodeId, string userName, BatchNodeUserUpdateOptions body, int? timeOut = null, DateTimeOffset? ocpDate = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));
            Argument.AssertNotNullOrEmpty(userName, nameof(userName));
            Argument.AssertNotNull(body, nameof(body));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = body.ToRequestContent();
            Response response = ReplaceNodeUser(poolId, nodeId, userName, content, timeOut, ocpDate, context);
            return response;
        }

        /// <summary>
        /// [Protocol Method] Updates the password and expiration time of a user Account on the specified Compute Node.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="ReplaceNodeUserAsync(string,string,string,BatchNodeUserUpdateOptions,int?,DateTimeOffset?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the machine on which you want to update a user Account. </param>
        /// <param name="userName"> The name of the user Account to update. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/>, <paramref name="nodeId"/>, <paramref name="userName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="userName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='ReplaceNodeUserAsync(string,string,string,RequestContent,int?,DateTimeOffset?,RequestContext)']/*" />
        public virtual async Task<Response> ReplaceNodeUserAsync(string poolId, string nodeId, string userName, RequestContent content, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));
            Argument.AssertNotNullOrEmpty(userName, nameof(userName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.ReplaceNodeUser");
            scope.Start();
            try
            {
                using HttpMessage message = CreateReplaceNodeUserRequest(poolId, nodeId, userName, content, timeOut, ocpDate, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Updates the password and expiration time of a user Account on the specified Compute Node.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="ReplaceNodeUser(string,string,string,BatchNodeUserUpdateOptions,int?,DateTimeOffset?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the machine on which you want to update a user Account. </param>
        /// <param name="userName"> The name of the user Account to update. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/>, <paramref name="nodeId"/>, <paramref name="userName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="userName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='ReplaceNodeUser(string,string,string,RequestContent,int?,DateTimeOffset?,RequestContext)']/*" />
        public virtual Response ReplaceNodeUser(string poolId, string nodeId, string userName, RequestContent content, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));
            Argument.AssertNotNullOrEmpty(userName, nameof(userName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.ReplaceNodeUser");
            scope.Start();
            try
            {
                using HttpMessage message = CreateReplaceNodeUserRequest(poolId, nodeId, userName, content, timeOut, ocpDate, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets information about the specified Compute Node. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node that you want to get information about. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetNodeAsync(string,string,int?,DateTimeOffset?,IEnumerable{string},CancellationToken)']/*" />
        public virtual async Task<Response<BatchNode>> GetNodeAsync(string poolId, string nodeId, int? timeOut = null, DateTimeOffset? ocpDate = null, IEnumerable<string> select = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetNodeAsync(poolId, nodeId, timeOut, ocpDate, select, context).ConfigureAwait(false);
            return Response.FromValue(BatchNode.FromResponse(response), response);
        }

        /// <summary> Gets information about the specified Compute Node. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node that you want to get information about. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetNode(string,string,int?,DateTimeOffset?,IEnumerable{string},CancellationToken)']/*" />
        public virtual Response<BatchNode> GetNode(string poolId, string nodeId, int? timeOut = null, DateTimeOffset? ocpDate = null, IEnumerable<string> select = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetNode(poolId, nodeId, timeOut, ocpDate, select, context);
            return Response.FromValue(BatchNode.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Gets information about the specified Compute Node.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetNodeAsync(string,string,int?,DateTimeOffset?,IEnumerable{string},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node that you want to get information about. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetNodeAsync(string,string,int?,DateTimeOffset?,IEnumerable{string},RequestContext)']/*" />
        public virtual async Task<Response> GetNodeAsync(string poolId, string nodeId, int? timeOut, DateTimeOffset? ocpDate, IEnumerable<string> select, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetNode");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetNodeRequest(poolId, nodeId, timeOut, ocpDate, select, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Gets information about the specified Compute Node.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetNode(string,string,int?,DateTimeOffset?,IEnumerable{string},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node that you want to get information about. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetNode(string,string,int?,DateTimeOffset?,IEnumerable{string},RequestContext)']/*" />
        public virtual Response GetNode(string poolId, string nodeId, int? timeOut, DateTimeOffset? ocpDate, IEnumerable<string> select, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetNode");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetNodeRequest(poolId, nodeId, timeOut, ocpDate, select, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Restarts the specified Compute Node. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node that you want to restart. </param>
        /// <param name="body"> The options to use for rebooting the Compute Node. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> You can restart a Compute Node only if it is in an idle or running state. </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='RebootNodeAsync(string,string,NodeRebootOptions,int?,DateTimeOffset?,CancellationToken)']/*" />
        public virtual async Task<Response> RebootNodeAsync(string poolId, string nodeId, NodeRebootOptions body = null, int? timeOut = null, DateTimeOffset? ocpDate = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = body?.ToRequestContent();
            Response response = await RebootNodeAsync(poolId, nodeId, content, timeOut, ocpDate, context).ConfigureAwait(false);
            return response;
        }

        /// <summary> Restarts the specified Compute Node. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node that you want to restart. </param>
        /// <param name="body"> The options to use for rebooting the Compute Node. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> You can restart a Compute Node only if it is in an idle or running state. </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='RebootNode(string,string,NodeRebootOptions,int?,DateTimeOffset?,CancellationToken)']/*" />
        public virtual Response RebootNode(string poolId, string nodeId, NodeRebootOptions body = null, int? timeOut = null, DateTimeOffset? ocpDate = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = body?.ToRequestContent();
            Response response = RebootNode(poolId, nodeId, content, timeOut, ocpDate, context);
            return response;
        }

        /// <summary>
        /// [Protocol Method] Restarts the specified Compute Node.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="RebootNodeAsync(string,string,NodeRebootOptions,int?,DateTimeOffset?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node that you want to restart. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='RebootNodeAsync(string,string,RequestContent,int?,DateTimeOffset?,RequestContext)']/*" />
        public virtual async Task<Response> RebootNodeAsync(string poolId, string nodeId, RequestContent content, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.RebootNode");
            scope.Start();
            try
            {
                using HttpMessage message = CreateRebootNodeRequest(poolId, nodeId, content, timeOut, ocpDate, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Restarts the specified Compute Node.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="RebootNode(string,string,NodeRebootOptions,int?,DateTimeOffset?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node that you want to restart. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='RebootNode(string,string,RequestContent,int?,DateTimeOffset?,RequestContext)']/*" />
        public virtual Response RebootNode(string poolId, string nodeId, RequestContent content, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.RebootNode");
            scope.Start();
            try
            {
                using HttpMessage message = CreateRebootNodeRequest(poolId, nodeId, content, timeOut, ocpDate, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Reinstalls the operating system on the specified Compute Node. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node that you want to restart. </param>
        /// <param name="body"> The options to use for reimaging the Compute Node. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// You can reinstall the operating system on a Compute Node only if it is in an
        /// idle or running state. This API can be invoked only on Pools created with the
        /// cloud service configuration property.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='ReimageNodeAsync(string,string,NodeReimageOptions,int?,DateTimeOffset?,CancellationToken)']/*" />
        public virtual async Task<Response> ReimageNodeAsync(string poolId, string nodeId, NodeReimageOptions body = null, int? timeOut = null, DateTimeOffset? ocpDate = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = body?.ToRequestContent();
            Response response = await ReimageNodeAsync(poolId, nodeId, content, timeOut, ocpDate, context).ConfigureAwait(false);
            return response;
        }

        /// <summary> Reinstalls the operating system on the specified Compute Node. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node that you want to restart. </param>
        /// <param name="body"> The options to use for reimaging the Compute Node. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// You can reinstall the operating system on a Compute Node only if it is in an
        /// idle or running state. This API can be invoked only on Pools created with the
        /// cloud service configuration property.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='ReimageNode(string,string,NodeReimageOptions,int?,DateTimeOffset?,CancellationToken)']/*" />
        public virtual Response ReimageNode(string poolId, string nodeId, NodeReimageOptions body = null, int? timeOut = null, DateTimeOffset? ocpDate = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = body?.ToRequestContent();
            Response response = ReimageNode(poolId, nodeId, content, timeOut, ocpDate, context);
            return response;
        }

        /// <summary>
        /// [Protocol Method] Reinstalls the operating system on the specified Compute Node.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="ReimageNodeAsync(string,string,NodeReimageOptions,int?,DateTimeOffset?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node that you want to restart. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='ReimageNodeAsync(string,string,RequestContent,int?,DateTimeOffset?,RequestContext)']/*" />
        public virtual async Task<Response> ReimageNodeAsync(string poolId, string nodeId, RequestContent content, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.ReimageNode");
            scope.Start();
            try
            {
                using HttpMessage message = CreateReimageNodeRequest(poolId, nodeId, content, timeOut, ocpDate, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Reinstalls the operating system on the specified Compute Node.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="ReimageNode(string,string,NodeReimageOptions,int?,DateTimeOffset?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node that you want to restart. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='ReimageNode(string,string,RequestContent,int?,DateTimeOffset?,RequestContext)']/*" />
        public virtual Response ReimageNode(string poolId, string nodeId, RequestContent content, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.ReimageNode");
            scope.Start();
            try
            {
                using HttpMessage message = CreateReimageNodeRequest(poolId, nodeId, content, timeOut, ocpDate, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Disables Task scheduling on the specified Compute Node. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node on which you want to disable Task scheduling. </param>
        /// <param name="body"> The options to use for disabling scheduling on the Compute Node. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// You can disable Task scheduling on a Compute Node only if its current
        /// scheduling state is enabled.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='DisableNodeSchedulingAsync(string,string,NodeDisableSchedulingOptions,int?,DateTimeOffset?,CancellationToken)']/*" />
        public virtual async Task<Response> DisableNodeSchedulingAsync(string poolId, string nodeId, NodeDisableSchedulingOptions body = null, int? timeOut = null, DateTimeOffset? ocpDate = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = body?.ToRequestContent();
            Response response = await DisableNodeSchedulingAsync(poolId, nodeId, content, timeOut, ocpDate, context).ConfigureAwait(false);
            return response;
        }

        /// <summary> Disables Task scheduling on the specified Compute Node. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node on which you want to disable Task scheduling. </param>
        /// <param name="body"> The options to use for disabling scheduling on the Compute Node. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// You can disable Task scheduling on a Compute Node only if its current
        /// scheduling state is enabled.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='DisableNodeScheduling(string,string,NodeDisableSchedulingOptions,int?,DateTimeOffset?,CancellationToken)']/*" />
        public virtual Response DisableNodeScheduling(string poolId, string nodeId, NodeDisableSchedulingOptions body = null, int? timeOut = null, DateTimeOffset? ocpDate = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = body?.ToRequestContent();
            Response response = DisableNodeScheduling(poolId, nodeId, content, timeOut, ocpDate, context);
            return response;
        }

        /// <summary>
        /// [Protocol Method] Disables Task scheduling on the specified Compute Node.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="DisableNodeSchedulingAsync(string,string,NodeDisableSchedulingOptions,int?,DateTimeOffset?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node on which you want to disable Task scheduling. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='DisableNodeSchedulingAsync(string,string,RequestContent,int?,DateTimeOffset?,RequestContext)']/*" />
        public virtual async Task<Response> DisableNodeSchedulingAsync(string poolId, string nodeId, RequestContent content, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.DisableNodeScheduling");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDisableNodeSchedulingRequest(poolId, nodeId, content, timeOut, ocpDate, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Disables Task scheduling on the specified Compute Node.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="DisableNodeScheduling(string,string,NodeDisableSchedulingOptions,int?,DateTimeOffset?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node on which you want to disable Task scheduling. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='DisableNodeScheduling(string,string,RequestContent,int?,DateTimeOffset?,RequestContext)']/*" />
        public virtual Response DisableNodeScheduling(string poolId, string nodeId, RequestContent content, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.DisableNodeScheduling");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDisableNodeSchedulingRequest(poolId, nodeId, content, timeOut, ocpDate, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Enables Task scheduling on the specified Compute Node.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node on which you want to enable Task scheduling. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='EnableNodeSchedulingAsync(string,string,int?,DateTimeOffset?,RequestContext)']/*" />
        public virtual async Task<Response> EnableNodeSchedulingAsync(string poolId, string nodeId, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.EnableNodeScheduling");
            scope.Start();
            try
            {
                using HttpMessage message = CreateEnableNodeSchedulingRequest(poolId, nodeId, timeOut, ocpDate, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Enables Task scheduling on the specified Compute Node.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node on which you want to enable Task scheduling. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='EnableNodeScheduling(string,string,int?,DateTimeOffset?,RequestContext)']/*" />
        public virtual Response EnableNodeScheduling(string poolId, string nodeId, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.EnableNodeScheduling");
            scope.Start();
            try
            {
                using HttpMessage message = CreateEnableNodeSchedulingRequest(poolId, nodeId, timeOut, ocpDate, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the settings required for remote login to a Compute Node. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node for which to obtain the remote login settings. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Before you can remotely login to a Compute Node using the remote login
        /// settings, you must create a user Account on the Compute Node. This API can be
        /// invoked only on Pools created with the virtual machine configuration property.
        /// For Pools created with a cloud service configuration, see the GetRemoteDesktop
        /// API.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetNodeRemoteLoginSettingsAsync(string,string,int?,DateTimeOffset?,CancellationToken)']/*" />
        public virtual async Task<Response<BatchNodeRemoteLoginSettingsResult>> GetNodeRemoteLoginSettingsAsync(string poolId, string nodeId, int? timeOut = null, DateTimeOffset? ocpDate = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetNodeRemoteLoginSettingsAsync(poolId, nodeId, timeOut, ocpDate, context).ConfigureAwait(false);
            return Response.FromValue(BatchNodeRemoteLoginSettingsResult.FromResponse(response), response);
        }

        /// <summary> Gets the settings required for remote login to a Compute Node. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node for which to obtain the remote login settings. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Before you can remotely login to a Compute Node using the remote login
        /// settings, you must create a user Account on the Compute Node. This API can be
        /// invoked only on Pools created with the virtual machine configuration property.
        /// For Pools created with a cloud service configuration, see the GetRemoteDesktop
        /// API.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetNodeRemoteLoginSettings(string,string,int?,DateTimeOffset?,CancellationToken)']/*" />
        public virtual Response<BatchNodeRemoteLoginSettingsResult> GetNodeRemoteLoginSettings(string poolId, string nodeId, int? timeOut = null, DateTimeOffset? ocpDate = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetNodeRemoteLoginSettings(poolId, nodeId, timeOut, ocpDate, context);
            return Response.FromValue(BatchNodeRemoteLoginSettingsResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Gets the settings required for remote login to a Compute Node.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetNodeRemoteLoginSettingsAsync(string,string,int?,DateTimeOffset?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node for which to obtain the remote login settings. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetNodeRemoteLoginSettingsAsync(string,string,int?,DateTimeOffset?,RequestContext)']/*" />
        public virtual async Task<Response> GetNodeRemoteLoginSettingsAsync(string poolId, string nodeId, int? timeOut, DateTimeOffset? ocpDate, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetNodeRemoteLoginSettings");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetNodeRemoteLoginSettingsRequest(poolId, nodeId, timeOut, ocpDate, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Gets the settings required for remote login to a Compute Node.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetNodeRemoteLoginSettings(string,string,int?,DateTimeOffset?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node for which to obtain the remote login settings. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetNodeRemoteLoginSettings(string,string,int?,DateTimeOffset?,RequestContext)']/*" />
        public virtual Response GetNodeRemoteLoginSettings(string poolId, string nodeId, int? timeOut, DateTimeOffset? ocpDate, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetNodeRemoteLoginSettings");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetNodeRemoteLoginSettingsRequest(poolId, nodeId, timeOut, ocpDate, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the Remote Desktop Protocol file for the specified Compute Node. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId">
        /// The ID of the Compute Node for which you want to get the Remote Desktop
        /// Protocol file.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Before you can access a Compute Node by using the RDP file, you must create a
        /// user Account on the Compute Node. This API can only be invoked on Pools created
        /// with a cloud service configuration. For Pools created with a virtual machine
        /// configuration, see the GetRemoteLoginSettings API.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetNodeRemoteDesktopFileAsync(string,string,int?,DateTimeOffset?,CancellationToken)']/*" />
        public virtual async Task<Response<BinaryData>> GetNodeRemoteDesktopFileAsync(string poolId, string nodeId, int? timeOut = null, DateTimeOffset? ocpDate = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetNodeRemoteDesktopFileAsync(poolId, nodeId, timeOut, ocpDate, context).ConfigureAwait(false);
            return Response.FromValue(response.Content, response);
        }

        /// <summary> Gets the Remote Desktop Protocol file for the specified Compute Node. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId">
        /// The ID of the Compute Node for which you want to get the Remote Desktop
        /// Protocol file.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Before you can access a Compute Node by using the RDP file, you must create a
        /// user Account on the Compute Node. This API can only be invoked on Pools created
        /// with a cloud service configuration. For Pools created with a virtual machine
        /// configuration, see the GetRemoteLoginSettings API.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetNodeRemoteDesktopFile(string,string,int?,DateTimeOffset?,CancellationToken)']/*" />
        public virtual Response<BinaryData> GetNodeRemoteDesktopFile(string poolId, string nodeId, int? timeOut = null, DateTimeOffset? ocpDate = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetNodeRemoteDesktopFile(poolId, nodeId, timeOut, ocpDate, context);
            return Response.FromValue(response.Content, response);
        }

        /// <summary>
        /// [Protocol Method] Gets the Remote Desktop Protocol file for the specified Compute Node.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetNodeRemoteDesktopFileAsync(string,string,int?,DateTimeOffset?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId">
        /// The ID of the Compute Node for which you want to get the Remote Desktop
        /// Protocol file.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetNodeRemoteDesktopFileAsync(string,string,int?,DateTimeOffset?,RequestContext)']/*" />
        public virtual async Task<Response> GetNodeRemoteDesktopFileAsync(string poolId, string nodeId, int? timeOut, DateTimeOffset? ocpDate, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetNodeRemoteDesktopFile");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetNodeRemoteDesktopFileRequest(poolId, nodeId, timeOut, ocpDate, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Gets the Remote Desktop Protocol file for the specified Compute Node.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetNodeRemoteDesktopFile(string,string,int?,DateTimeOffset?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId">
        /// The ID of the Compute Node for which you want to get the Remote Desktop
        /// Protocol file.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetNodeRemoteDesktopFile(string,string,int?,DateTimeOffset?,RequestContext)']/*" />
        public virtual Response GetNodeRemoteDesktopFile(string poolId, string nodeId, int? timeOut, DateTimeOffset? ocpDate, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetNodeRemoteDesktopFile");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetNodeRemoteDesktopFileRequest(poolId, nodeId, timeOut, ocpDate, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// Upload Azure Batch service log files from the specified Compute Node to Azure
        /// Blob Storage.
        /// </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId">
        /// The ID of the Compute Node for which you want to get the Remote Desktop
        /// Protocol file.
        /// </param>
        /// <param name="body"> The Azure Batch service log files upload options. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// This is for gathering Azure Batch service log files in an automated fashion
        /// from Compute Nodes if you are experiencing an error and wish to escalate to
        /// Azure support. The Azure Batch service log files should be shared with Azure
        /// support to aid in debugging issues with the Batch service.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='UploadNodeLogsAsync(string,string,UploadBatchServiceLogsOptions,int?,DateTimeOffset?,CancellationToken)']/*" />
        public virtual async Task<Response<UploadBatchServiceLogsResult>> UploadNodeLogsAsync(string poolId, string nodeId, UploadBatchServiceLogsOptions body, int? timeOut = null, DateTimeOffset? ocpDate = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));
            Argument.AssertNotNull(body, nameof(body));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = body.ToRequestContent();
            Response response = await UploadNodeLogsAsync(poolId, nodeId, content, timeOut, ocpDate, context).ConfigureAwait(false);
            return Response.FromValue(UploadBatchServiceLogsResult.FromResponse(response), response);
        }

        /// <summary>
        /// Upload Azure Batch service log files from the specified Compute Node to Azure
        /// Blob Storage.
        /// </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId">
        /// The ID of the Compute Node for which you want to get the Remote Desktop
        /// Protocol file.
        /// </param>
        /// <param name="body"> The Azure Batch service log files upload options. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="body"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// This is for gathering Azure Batch service log files in an automated fashion
        /// from Compute Nodes if you are experiencing an error and wish to escalate to
        /// Azure support. The Azure Batch service log files should be shared with Azure
        /// support to aid in debugging issues with the Batch service.
        /// </remarks>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='UploadNodeLogs(string,string,UploadBatchServiceLogsOptions,int?,DateTimeOffset?,CancellationToken)']/*" />
        public virtual Response<UploadBatchServiceLogsResult> UploadNodeLogs(string poolId, string nodeId, UploadBatchServiceLogsOptions body, int? timeOut = null, DateTimeOffset? ocpDate = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));
            Argument.AssertNotNull(body, nameof(body));

            RequestContext context = FromCancellationToken(cancellationToken);
            using RequestContent content = body.ToRequestContent();
            Response response = UploadNodeLogs(poolId, nodeId, content, timeOut, ocpDate, context);
            return Response.FromValue(UploadBatchServiceLogsResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Upload Azure Batch service log files from the specified Compute Node to Azure
        /// Blob Storage.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="UploadNodeLogsAsync(string,string,UploadBatchServiceLogsOptions,int?,DateTimeOffset?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId">
        /// The ID of the Compute Node for which you want to get the Remote Desktop
        /// Protocol file.
        /// </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='UploadNodeLogsAsync(string,string,RequestContent,int?,DateTimeOffset?,RequestContext)']/*" />
        public virtual async Task<Response> UploadNodeLogsAsync(string poolId, string nodeId, RequestContent content, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.UploadNodeLogs");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUploadNodeLogsRequest(poolId, nodeId, content, timeOut, ocpDate, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Upload Azure Batch service log files from the specified Compute Node to Azure
        /// Blob Storage.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="UploadNodeLogs(string,string,UploadBatchServiceLogsOptions,int?,DateTimeOffset?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId">
        /// The ID of the Compute Node for which you want to get the Remote Desktop
        /// Protocol file.
        /// </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='UploadNodeLogs(string,string,RequestContent,int?,DateTimeOffset?,RequestContext)']/*" />
        public virtual Response UploadNodeLogs(string poolId, string nodeId, RequestContent content, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.UploadNodeLogs");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUploadNodeLogsRequest(poolId, nodeId, content, timeOut, ocpDate, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Lists the Compute Nodes in the specified Pool. </summary>
        /// <param name="poolId"> The ID of the Pool from which you want to list Compute Nodes. </param>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-nodes-in-a-pool.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetNodesAsync(string,int?,DateTimeOffset?,int?,string,IEnumerable{string},CancellationToken)']/*" />
        public virtual async Task<Response<BatchNodeListResult>> GetNodesAsync(string poolId, int? maxresults = null, DateTimeOffset? ocpDate = null, int? timeOut = null, string filter = null, IEnumerable<string> select = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetNodesAsync(poolId, maxresults, ocpDate, timeOut, filter, select, context).ConfigureAwait(false);
            return Response.FromValue(BatchNodeListResult.FromResponse(response), response);
        }

        /// <summary> Lists the Compute Nodes in the specified Pool. </summary>
        /// <param name="poolId"> The ID of the Pool from which you want to list Compute Nodes. </param>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-nodes-in-a-pool.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetNodes(string,int?,DateTimeOffset?,int?,string,IEnumerable{string},CancellationToken)']/*" />
        public virtual Response<BatchNodeListResult> GetNodes(string poolId, int? maxresults = null, DateTimeOffset? ocpDate = null, int? timeOut = null, string filter = null, IEnumerable<string> select = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetNodes(poolId, maxresults, ocpDate, timeOut, filter, select, context);
            return Response.FromValue(BatchNodeListResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Lists the Compute Nodes in the specified Pool.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetNodesAsync(string,int?,DateTimeOffset?,int?,string,IEnumerable{string},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool from which you want to list Compute Nodes. </param>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-nodes-in-a-pool.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetNodesAsync(string,int?,DateTimeOffset?,int?,string,IEnumerable{string},RequestContext)']/*" />
        public virtual async Task<Response> GetNodesAsync(string poolId, int? maxresults, DateTimeOffset? ocpDate, int? timeOut, string filter, IEnumerable<string> select, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetNodes");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetNodesRequest(poolId, maxresults, ocpDate, timeOut, filter, select, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Lists the Compute Nodes in the specified Pool.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetNodes(string,int?,DateTimeOffset?,int?,string,IEnumerable{string},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool from which you want to list Compute Nodes. </param>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-nodes-in-a-pool.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetNodes(string,int?,DateTimeOffset?,int?,string,IEnumerable{string},RequestContext)']/*" />
        public virtual Response GetNodes(string poolId, int? maxresults, DateTimeOffset? ocpDate, int? timeOut, string filter, IEnumerable<string> select, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetNodes");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetNodesRequest(poolId, maxresults, ocpDate, timeOut, filter, select, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets information about the specified Compute Node Extension. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node that contains the extensions. </param>
        /// <param name="extensionName">
        /// The name of the of the Compute Node Extension that you want to get information
        /// about.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="extensionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="extensionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetNodeExtensionAsync(string,string,string,int?,DateTimeOffset?,IEnumerable{string},CancellationToken)']/*" />
        public virtual async Task<Response<NodeVMExtension>> GetNodeExtensionAsync(string poolId, string nodeId, string extensionName, int? timeOut = null, DateTimeOffset? ocpDate = null, IEnumerable<string> select = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));
            Argument.AssertNotNullOrEmpty(extensionName, nameof(extensionName));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetNodeExtensionAsync(poolId, nodeId, extensionName, timeOut, ocpDate, select, context).ConfigureAwait(false);
            return Response.FromValue(NodeVMExtension.FromResponse(response), response);
        }

        /// <summary> Gets information about the specified Compute Node Extension. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node that contains the extensions. </param>
        /// <param name="extensionName">
        /// The name of the of the Compute Node Extension that you want to get information
        /// about.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="extensionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="extensionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetNodeExtension(string,string,string,int?,DateTimeOffset?,IEnumerable{string},CancellationToken)']/*" />
        public virtual Response<NodeVMExtension> GetNodeExtension(string poolId, string nodeId, string extensionName, int? timeOut = null, DateTimeOffset? ocpDate = null, IEnumerable<string> select = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));
            Argument.AssertNotNullOrEmpty(extensionName, nameof(extensionName));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetNodeExtension(poolId, nodeId, extensionName, timeOut, ocpDate, select, context);
            return Response.FromValue(NodeVMExtension.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Gets information about the specified Compute Node Extension.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetNodeExtensionAsync(string,string,string,int?,DateTimeOffset?,IEnumerable{string},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node that contains the extensions. </param>
        /// <param name="extensionName">
        /// The name of the of the Compute Node Extension that you want to get information
        /// about.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="extensionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="extensionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetNodeExtensionAsync(string,string,string,int?,DateTimeOffset?,IEnumerable{string},RequestContext)']/*" />
        public virtual async Task<Response> GetNodeExtensionAsync(string poolId, string nodeId, string extensionName, int? timeOut, DateTimeOffset? ocpDate, IEnumerable<string> select, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));
            Argument.AssertNotNullOrEmpty(extensionName, nameof(extensionName));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetNodeExtension");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetNodeExtensionRequest(poolId, nodeId, extensionName, timeOut, ocpDate, select, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Gets information about the specified Compute Node Extension.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetNodeExtension(string,string,string,int?,DateTimeOffset?,IEnumerable{string},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node that contains the extensions. </param>
        /// <param name="extensionName">
        /// The name of the of the Compute Node Extension that you want to get information
        /// about.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="extensionName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="extensionName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetNodeExtension(string,string,string,int?,DateTimeOffset?,IEnumerable{string},RequestContext)']/*" />
        public virtual Response GetNodeExtension(string poolId, string nodeId, string extensionName, int? timeOut, DateTimeOffset? ocpDate, IEnumerable<string> select, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));
            Argument.AssertNotNullOrEmpty(extensionName, nameof(extensionName));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetNodeExtension");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetNodeExtensionRequest(poolId, nodeId, extensionName, timeOut, ocpDate, select, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Lists the Compute Nodes Extensions in the specified Pool. </summary>
        /// <param name="poolId"> The ID of the Pool that contains Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node that you want to list extensions. </param>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetNodeExtensionsAsync(string,string,int?,DateTimeOffset?,int?,IEnumerable{string},CancellationToken)']/*" />
        public virtual async Task<Response<NodeVMExtensionList>> GetNodeExtensionsAsync(string poolId, string nodeId, int? maxresults = null, DateTimeOffset? ocpDate = null, int? timeOut = null, IEnumerable<string> select = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetNodeExtensionsAsync(poolId, nodeId, maxresults, ocpDate, timeOut, select, context).ConfigureAwait(false);
            return Response.FromValue(NodeVMExtensionList.FromResponse(response), response);
        }

        /// <summary> Lists the Compute Nodes Extensions in the specified Pool. </summary>
        /// <param name="poolId"> The ID of the Pool that contains Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node that you want to list extensions. </param>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetNodeExtensions(string,string,int?,DateTimeOffset?,int?,IEnumerable{string},CancellationToken)']/*" />
        public virtual Response<NodeVMExtensionList> GetNodeExtensions(string poolId, string nodeId, int? maxresults = null, DateTimeOffset? ocpDate = null, int? timeOut = null, IEnumerable<string> select = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetNodeExtensions(poolId, nodeId, maxresults, ocpDate, timeOut, select, context);
            return Response.FromValue(NodeVMExtensionList.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Lists the Compute Nodes Extensions in the specified Pool.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetNodeExtensionsAsync(string,string,int?,DateTimeOffset?,int?,IEnumerable{string},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool that contains Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node that you want to list extensions. </param>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetNodeExtensionsAsync(string,string,int?,DateTimeOffset?,int?,IEnumerable{string},RequestContext)']/*" />
        public virtual async Task<Response> GetNodeExtensionsAsync(string poolId, string nodeId, int? maxresults, DateTimeOffset? ocpDate, int? timeOut, IEnumerable<string> select, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetNodeExtensions");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetNodeExtensionsRequest(poolId, nodeId, maxresults, ocpDate, timeOut, select, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Lists the Compute Nodes Extensions in the specified Pool.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetNodeExtensions(string,string,int?,DateTimeOffset?,int?,IEnumerable{string},CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool that contains Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node that you want to list extensions. </param>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetNodeExtensions(string,string,int?,DateTimeOffset?,int?,IEnumerable{string},RequestContext)']/*" />
        public virtual Response GetNodeExtensions(string poolId, string nodeId, int? maxresults, DateTimeOffset? ocpDate, int? timeOut, IEnumerable<string> select, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetNodeExtensions");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetNodeExtensionsRequest(poolId, nodeId, maxresults, ocpDate, timeOut, select, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Deletes the specified file from the Compute Node.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node from which you want to delete the file. </param>
        /// <param name="filePath"> The path to the file or directory that you want to delete. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="recursive">
        /// Whether to delete children of a directory. If the filePath parameter represents
        /// a directory instead of a file, you can set recursive to true to delete the
        /// directory and all of the files and subdirectories in it. If recursive is false
        /// then the directory must be empty or deletion will fail.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="filePath"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="filePath"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='DeleteNodeFileAsync(string,string,string,int?,DateTimeOffset?,bool?,RequestContext)']/*" />
        public virtual async Task<Response> DeleteNodeFileAsync(string poolId, string nodeId, string filePath, int? timeOut = null, DateTimeOffset? ocpDate = null, bool? recursive = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));
            Argument.AssertNotNullOrEmpty(filePath, nameof(filePath));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.DeleteNodeFile");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteNodeFileRequest(poolId, nodeId, filePath, timeOut, ocpDate, recursive, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Deletes the specified file from the Compute Node.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node from which you want to delete the file. </param>
        /// <param name="filePath"> The path to the file or directory that you want to delete. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="recursive">
        /// Whether to delete children of a directory. If the filePath parameter represents
        /// a directory instead of a file, you can set recursive to true to delete the
        /// directory and all of the files and subdirectories in it. If recursive is false
        /// then the directory must be empty or deletion will fail.
        /// </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="filePath"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="filePath"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='DeleteNodeFile(string,string,string,int?,DateTimeOffset?,bool?,RequestContext)']/*" />
        public virtual Response DeleteNodeFile(string poolId, string nodeId, string filePath, int? timeOut = null, DateTimeOffset? ocpDate = null, bool? recursive = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));
            Argument.AssertNotNullOrEmpty(filePath, nameof(filePath));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.DeleteNodeFile");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteNodeFileRequest(poolId, nodeId, filePath, timeOut, ocpDate, recursive, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Returns the content of the specified Compute Node file. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node from which you want to delete the file. </param>
        /// <param name="filePath"> The path to the file or directory that you want to delete. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="ocpRange">
        /// The byte range to be retrieved. The default is to retrieve the entire file. The
        /// format is bytes=startRange-endRange.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="filePath"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="filePath"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetNodeFileAsync(string,string,string,int?,DateTimeOffset?,string,RequestConditions,CancellationToken)']/*" />
        public virtual async Task<Response<BinaryData>> GetNodeFileAsync(string poolId, string nodeId, string filePath, int? timeOut = null, DateTimeOffset? ocpDate = null, string ocpRange = null, RequestConditions requestConditions = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));
            Argument.AssertNotNullOrEmpty(filePath, nameof(filePath));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetNodeFileAsync(poolId, nodeId, filePath, timeOut, ocpDate, ocpRange, requestConditions, context).ConfigureAwait(false);
            return Response.FromValue(response.Content, response);
        }

        /// <summary> Returns the content of the specified Compute Node file. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node from which you want to delete the file. </param>
        /// <param name="filePath"> The path to the file or directory that you want to delete. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="ocpRange">
        /// The byte range to be retrieved. The default is to retrieve the entire file. The
        /// format is bytes=startRange-endRange.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="filePath"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="filePath"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetNodeFile(string,string,string,int?,DateTimeOffset?,string,RequestConditions,CancellationToken)']/*" />
        public virtual Response<BinaryData> GetNodeFile(string poolId, string nodeId, string filePath, int? timeOut = null, DateTimeOffset? ocpDate = null, string ocpRange = null, RequestConditions requestConditions = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));
            Argument.AssertNotNullOrEmpty(filePath, nameof(filePath));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetNodeFile(poolId, nodeId, filePath, timeOut, ocpDate, ocpRange, requestConditions, context);
            return Response.FromValue(response.Content, response);
        }

        /// <summary>
        /// [Protocol Method] Returns the content of the specified Compute Node file.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetNodeFileAsync(string,string,string,int?,DateTimeOffset?,string,RequestConditions,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node from which you want to delete the file. </param>
        /// <param name="filePath"> The path to the file or directory that you want to delete. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="ocpRange">
        /// The byte range to be retrieved. The default is to retrieve the entire file. The
        /// format is bytes=startRange-endRange.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="filePath"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="filePath"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetNodeFileAsync(string,string,string,int?,DateTimeOffset?,string,RequestConditions,RequestContext)']/*" />
        public virtual async Task<Response> GetNodeFileAsync(string poolId, string nodeId, string filePath, int? timeOut, DateTimeOffset? ocpDate, string ocpRange, RequestConditions requestConditions, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));
            Argument.AssertNotNullOrEmpty(filePath, nameof(filePath));

            Argument.AssertNull(requestConditions.IfMatch, nameof(requestConditions), "Service does not support the If-Match header for this operation.");
            Argument.AssertNull(requestConditions.IfNoneMatch, nameof(requestConditions), "Service does not support the If-None-Match header for this operation.");

            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetNodeFile");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetNodeFileRequest(poolId, nodeId, filePath, timeOut, ocpDate, ocpRange, requestConditions, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Returns the content of the specified Compute Node file.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetNodeFile(string,string,string,int?,DateTimeOffset?,string,RequestConditions,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node from which you want to delete the file. </param>
        /// <param name="filePath"> The path to the file or directory that you want to delete. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="ocpRange">
        /// The byte range to be retrieved. The default is to retrieve the entire file. The
        /// format is bytes=startRange-endRange.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="filePath"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="filePath"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetNodeFile(string,string,string,int?,DateTimeOffset?,string,RequestConditions,RequestContext)']/*" />
        public virtual Response GetNodeFile(string poolId, string nodeId, string filePath, int? timeOut, DateTimeOffset? ocpDate, string ocpRange, RequestConditions requestConditions, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));
            Argument.AssertNotNullOrEmpty(filePath, nameof(filePath));

            Argument.AssertNull(requestConditions.IfMatch, nameof(requestConditions), "Service does not support the If-Match header for this operation.");
            Argument.AssertNull(requestConditions.IfNoneMatch, nameof(requestConditions), "Service does not support the If-None-Match header for this operation.");

            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetNodeFile");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetNodeFileRequest(poolId, nodeId, filePath, timeOut, ocpDate, ocpRange, requestConditions, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Gets the properties of the specified Compute Node file.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node from which you want to delete the file. </param>
        /// <param name="filePath"> The path to the file or directory that you want to delete. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="filePath"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="filePath"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetNodeFilePropertiesAsync(string,string,string,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual async Task<Response<bool>> GetNodeFilePropertiesAsync(string poolId, string nodeId, string filePath, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));
            Argument.AssertNotNullOrEmpty(filePath, nameof(filePath));

            Argument.AssertNull(requestConditions.IfMatch, nameof(requestConditions), "Service does not support the If-Match header for this operation.");
            Argument.AssertNull(requestConditions.IfNoneMatch, nameof(requestConditions), "Service does not support the If-None-Match header for this operation.");

            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetNodeFileProperties");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetNodeFilePropertiesRequest(poolId, nodeId, filePath, timeOut, ocpDate, requestConditions, context);
                return await _pipeline.ProcessHeadAsBoolMessageAsync(message, ClientDiagnostics, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        // The convenience method is omitted here because it has exactly the same parameter list as the corresponding protocol method
        /// <summary>
        /// [Protocol Method] Gets the properties of the specified Compute Node file.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node from which you want to delete the file. </param>
        /// <param name="filePath"> The path to the file or directory that you want to delete. </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="filePath"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="filePath"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetNodeFileProperties(string,string,string,int?,DateTimeOffset?,RequestConditions,RequestContext)']/*" />
        public virtual Response<bool> GetNodeFileProperties(string poolId, string nodeId, string filePath, int? timeOut = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));
            Argument.AssertNotNullOrEmpty(filePath, nameof(filePath));

            Argument.AssertNull(requestConditions.IfMatch, nameof(requestConditions), "Service does not support the If-Match header for this operation.");
            Argument.AssertNull(requestConditions.IfNoneMatch, nameof(requestConditions), "Service does not support the If-None-Match header for this operation.");

            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetNodeFileProperties");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetNodeFilePropertiesRequest(poolId, nodeId, filePath, timeOut, ocpDate, requestConditions, context);
                return _pipeline.ProcessHeadAsBoolMessage(message, ClientDiagnostics, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Lists all of the files in Task directories on the specified Compute Node. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node whose files you want to list. </param>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-compute-node-files.
        /// </param>
        /// <param name="recursive"> Whether to list children of a directory. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetNodeFilesAsync(string,string,int?,DateTimeOffset?,int?,string,bool?,CancellationToken)']/*" />
        public virtual async Task<Response<NodeFileListResult>> GetNodeFilesAsync(string poolId, string nodeId, int? maxresults = null, DateTimeOffset? ocpDate = null, int? timeOut = null, string filter = null, bool? recursive = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = await GetNodeFilesAsync(poolId, nodeId, maxresults, ocpDate, timeOut, filter, recursive, context).ConfigureAwait(false);
            return Response.FromValue(NodeFileListResult.FromResponse(response), response);
        }

        /// <summary> Lists all of the files in Task directories on the specified Compute Node. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node whose files you want to list. </param>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-compute-node-files.
        /// </param>
        /// <param name="recursive"> Whether to list children of a directory. </param>
        /// <param name="cancellationToken"> The cancellation token to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetNodeFiles(string,string,int?,DateTimeOffset?,int?,string,bool?,CancellationToken)']/*" />
        public virtual Response<NodeFileListResult> GetNodeFiles(string poolId, string nodeId, int? maxresults = null, DateTimeOffset? ocpDate = null, int? timeOut = null, string filter = null, bool? recursive = null, CancellationToken cancellationToken = default)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            RequestContext context = FromCancellationToken(cancellationToken);
            Response response = GetNodeFiles(poolId, nodeId, maxresults, ocpDate, timeOut, filter, recursive, context);
            return Response.FromValue(NodeFileListResult.FromResponse(response), response);
        }

        /// <summary>
        /// [Protocol Method] Lists all of the files in Task directories on the specified Compute Node.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetNodeFilesAsync(string,string,int?,DateTimeOffset?,int?,string,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node whose files you want to list. </param>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-compute-node-files.
        /// </param>
        /// <param name="recursive"> Whether to list children of a directory. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetNodeFilesAsync(string,string,int?,DateTimeOffset?,int?,string,bool?,RequestContext)']/*" />
        public virtual async Task<Response> GetNodeFilesAsync(string poolId, string nodeId, int? maxresults, DateTimeOffset? ocpDate, int? timeOut, string filter, bool? recursive, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetNodeFiles");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetNodeFilesRequest(poolId, nodeId, maxresults, ocpDate, timeOut, filter, recursive, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary>
        /// [Protocol Method] Lists all of the files in Task directories on the specified Compute Node.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/ProtocolMethods.md">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetNodeFiles(string,string,int?,DateTimeOffset?,int?,string,bool?,CancellationToken)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node whose files you want to list. </param>
        /// <param name="maxresults">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="ocpDate">
        /// The time the request was issued. Client libraries typically set this to the
        /// current system clock time; set it explicitly if you are calling the REST API
        /// directly.
        /// </param>
        /// <param name="timeOut">
        /// The maximum number of items to return in the response. A maximum of 1000
        /// applications can be returned.
        /// </param>
        /// <param name="filter">
        /// An OData $filter clause. For more information on constructing this filter, see
        /// https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-compute-node-files.
        /// </param>
        /// <param name="recursive"> Whether to list children of a directory. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <include file="Docs/BatchClient.xml" path="doc/members/member[@name='GetNodeFiles(string,string,int?,DateTimeOffset?,int?,string,bool?,RequestContext)']/*" />
        public virtual Response GetNodeFiles(string poolId, string nodeId, int? maxresults, DateTimeOffset? ocpDate, int? timeOut, string filter, bool? recursive, RequestContext context)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            using var scope = ClientDiagnostics.CreateScope("BatchClient.GetNodeFiles");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetNodeFilesRequest(poolId, nodeId, maxresults, ocpDate, timeOut, filter, recursive, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateGetApplicationsRequest(int? maxresults, DateTimeOffset? ocpDate, int? timeOut, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/applications", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (maxresults != null)
            {
                uri.AppendQuery("maxresults", maxresults.Value, true);
            }
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            return message;
        }

        internal HttpMessage CreateGetApplicationRequest(string applicationId, int? timeOut, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/applications/", false);
            uri.AppendPath(applicationId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            return message;
        }

        internal HttpMessage CreateGetPoolUsageMetricsRequest(int? maxresults, DateTimeOffset? ocpDate, int? timeOut, DateTimeOffset? starttime, DateTimeOffset? endtime, string filter, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/poolusagemetrics", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (maxresults != null)
            {
                uri.AppendQuery("maxresults", maxresults.Value, true);
            }
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            if (starttime != null)
            {
                uri.AppendQuery("starttime", starttime.Value, "O", true);
            }
            if (endtime != null)
            {
                uri.AppendQuery("endtime", endtime.Value, "O", true);
            }
            if (filter != null)
            {
                uri.AppendQuery("$filter", filter, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            return message;
        }

        internal HttpMessage CreateCreateRequest(RequestContent content, int? timeOut, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier201);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/pools", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("content-type", "application/json; odata=minimalmetadata");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetPoolsRequest(int? maxresults, DateTimeOffset? ocpDate, int? timeOut, string filter, IEnumerable<string> select, IEnumerable<string> expand, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/pools", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (maxresults != null)
            {
                uri.AppendQuery("maxresults", maxresults.Value, true);
            }
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            if (filter != null)
            {
                uri.AppendQuery("$filter", filter, true);
            }
            if (select != null && Optional.IsCollectionDefined(select))
            {
                uri.AppendQueryDelimited("$select", select, ",", true);
            }
            if (expand != null && Optional.IsCollectionDefined(expand))
            {
                uri.AppendQueryDelimited("$expand", expand, ",", true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            return message;
        }

        internal HttpMessage CreateDeleteRequest(string poolId, int? timeOut, DateTimeOffset? ocpDate, RequestConditions requestConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            if (requestConditions != null)
            {
                request.Headers.Add(requestConditions, "R");
            }
            return message;
        }

        internal HttpMessage CreatePoolExistsRequest(string poolId, int? timeOut, DateTimeOffset? ocpDate, RequestConditions requestConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200To300400To500);
            var request = message.Request;
            request.Method = RequestMethod.Head;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            if (requestConditions != null)
            {
                request.Headers.Add(requestConditions, "R");
            }
            return message;
        }

        internal HttpMessage CreateGetPoolRequest(string poolId, int? timeOut, DateTimeOffset? ocpDate, IEnumerable<string> select, IEnumerable<string> expand, RequestConditions requestConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            if (select != null && Optional.IsCollectionDefined(select))
            {
                uri.AppendQueryDelimited("$select", select, ",", true);
            }
            if (expand != null && Optional.IsCollectionDefined(expand))
            {
                uri.AppendQueryDelimited("$expand", expand, ",", true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            if (requestConditions != null)
            {
                request.Headers.Add(requestConditions, "R");
            }
            return message;
        }

        internal HttpMessage CreateUpdateRequest(string poolId, RequestContent content, int? timeOut, DateTimeOffset? ocpDate, RequestConditions requestConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            if (requestConditions != null)
            {
                request.Headers.Add(requestConditions, "R");
            }
            request.Headers.Add("content-type", "application/json; odata=minimalmetadata");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDisablePoolAutoScaleRequest(string poolId, int? timeOut, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/disableautoscale", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            return message;
        }

        internal HttpMessage CreateEnablePoolAutoScaleRequest(string poolId, RequestContent content, int? timeOut, DateTimeOffset? ocpDate, RequestConditions requestConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/enableautoscale", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            if (requestConditions != null)
            {
                request.Headers.Add(requestConditions, "R");
            }
            request.Headers.Add("content-type", "application/json; odata=minimalmetadata");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateEvaluatePoolAutoScaleRequest(string poolId, RequestContent content, int? timeOut, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/evaluateautoscale", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("content-type", "application/json; odata=minimalmetadata");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateResizeRequest(string poolId, RequestContent content, int? timeOut, DateTimeOffset? ocpDate, RequestConditions requestConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/resize", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            if (requestConditions != null)
            {
                request.Headers.Add(requestConditions, "R");
            }
            request.Headers.Add("content-type", "application/json; odata=minimalmetadata");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateStopPoolResizeRequest(string poolId, int? timeOut, DateTimeOffset? ocpDate, RequestConditions requestConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/stopresize", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            if (requestConditions != null)
            {
                request.Headers.Add(requestConditions, "R");
            }
            return message;
        }

        internal HttpMessage CreateReplacePoolPropertiesRequest(string poolId, RequestContent content, int? timeOut, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/updateproperties", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("content-type", "application/json; odata=minimalmetadata");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateRemoveNodesRequest(string poolId, RequestContent content, int? timeOut, DateTimeOffset? ocpDate, RequestConditions requestConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/removenodes", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            if (requestConditions != null)
            {
                request.Headers.Add(requestConditions, "R");
            }
            request.Headers.Add("content-type", "application/json; odata=minimalmetadata");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetSupportedImagesRequest(int? maxresults, DateTimeOffset? ocpDate, int? timeOut, string filter, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/supportedimages", false);
            if (maxresults != null)
            {
                uri.AppendQuery("maxresults", maxresults.Value, true);
            }
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            if (filter != null)
            {
                uri.AppendQuery("$filter", filter, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            return message;
        }

        internal HttpMessage CreateGetPoolNodeCountsRequest(int? maxresults, DateTimeOffset? ocpDate, int? timeOut, string filter, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/nodecounts", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (maxresults != null)
            {
                uri.AppendQuery("maxresults", maxresults.Value, true);
            }
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            if (filter != null)
            {
                uri.AppendQuery("$filter", filter, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            return message;
        }

        internal HttpMessage CreateDeleteJobRequest(string jobId, int? timeOut, DateTimeOffset? ocpDate, RequestConditions requestConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            if (requestConditions != null)
            {
                request.Headers.Add(requestConditions, "R");
            }
            return message;
        }

        internal HttpMessage CreateGetJobRequest(string jobId, int? timeOut, DateTimeOffset? ocpDate, IEnumerable<string> select, IEnumerable<string> expand, RequestConditions requestConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            if (select != null && Optional.IsCollectionDefined(select))
            {
                uri.AppendQueryDelimited("$select", select, ",", true);
            }
            if (expand != null && Optional.IsCollectionDefined(expand))
            {
                uri.AppendQueryDelimited("$expand", expand, ",", true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            if (requestConditions != null)
            {
                request.Headers.Add(requestConditions, "R");
            }
            return message;
        }

        internal HttpMessage CreateUpdateJobRequest(string jobId, RequestContent content, int? timeOut, DateTimeOffset? ocpDate, RequestConditions requestConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            if (requestConditions != null)
            {
                request.Headers.Add(requestConditions, "R");
            }
            request.Headers.Add("content-type", "application/json; odata=minimalmetadata");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateReplaceJobRequest(string jobId, RequestContent content, int? timeOut, DateTimeOffset? ocpDate, RequestConditions requestConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            if (requestConditions != null)
            {
                request.Headers.Add(requestConditions, "R");
            }
            request.Headers.Add("content-type", "application/json; odata=minimalmetadata");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDisableJobRequest(string jobId, RequestContent content, int? timeOut, DateTimeOffset? ocpDate, RequestConditions requestConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/disable", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            if (requestConditions != null)
            {
                request.Headers.Add(requestConditions, "R");
            }
            request.Headers.Add("content-type", "application/json; odata=minimalmetadata");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateEnableJobRequest(string jobId, int? timeOut, DateTimeOffset? ocpDate, RequestConditions requestConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/enable", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            if (requestConditions != null)
            {
                request.Headers.Add(requestConditions, "R");
            }
            return message;
        }

        internal HttpMessage CreateTerminateJobRequest(string jobId, RequestContent content, int? timeOut, DateTimeOffset? ocpDate, RequestConditions requestConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/terminate", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            if (requestConditions != null)
            {
                request.Headers.Add(requestConditions, "R");
            }
            request.Headers.Add("content-type", "application/json; odata=minimalmetadata");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateCreateJobRequest(RequestContent content, int? timeOut, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier201);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/jobs", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("content-type", "application/json; odata=minimalmetadata");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetJobsRequest(int? maxresults, DateTimeOffset? ocpDate, int? timeOut, string filter, IEnumerable<string> select, IEnumerable<string> expand, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/jobs", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (maxresults != null)
            {
                uri.AppendQuery("maxresults", maxresults.Value, true);
            }
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            if (filter != null)
            {
                uri.AppendQuery("$filter", filter, true);
            }
            if (select != null && Optional.IsCollectionDefined(select))
            {
                uri.AppendQueryDelimited("$select", select, ",", true);
            }
            if (expand != null && Optional.IsCollectionDefined(expand))
            {
                uri.AppendQueryDelimited("$expand", expand, ",", true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            return message;
        }

        internal HttpMessage CreateGetJobsFromSchedulesRequest(string jobScheduleId, int? maxresults, DateTimeOffset? ocpDate, int? timeOut, string filter, IEnumerable<string> select, IEnumerable<string> expand, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/jobschedules/", false);
            uri.AppendPath(jobScheduleId, true);
            uri.AppendPath("/jobs", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (maxresults != null)
            {
                uri.AppendQuery("maxresults", maxresults.Value, true);
            }
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            if (filter != null)
            {
                uri.AppendQuery("$filter", filter, true);
            }
            if (select != null && Optional.IsCollectionDefined(select))
            {
                uri.AppendQueryDelimited("$select", select, ",", true);
            }
            if (expand != null && Optional.IsCollectionDefined(expand))
            {
                uri.AppendQueryDelimited("$expand", expand, ",", true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            return message;
        }

        internal HttpMessage CreateGetJobPreparationAndReleaseTaskStatusesRequest(string jobId, int? maxresults, DateTimeOffset? ocpDate, int? timeOut, string filter, IEnumerable<string> select, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/jobpreparationandreleasetaskstatus", false);
            if (maxresults != null)
            {
                uri.AppendQuery("maxresults", maxresults.Value, true);
            }
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            if (filter != null)
            {
                uri.AppendQuery("$filter", filter, true);
            }
            if (select != null && Optional.IsCollectionDefined(select))
            {
                uri.AppendQueryDelimited("$select", select, ",", true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            return message;
        }

        internal HttpMessage CreateGetJobTaskCountsRequest(string jobId, int? timeOut, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/taskcounts", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            return message;
        }

        internal HttpMessage CreateCreateCertificateRequest(RequestContent content, int? timeOut, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier201);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/certificates", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("content-type", "application/json; odata=minimalmetadata");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetCertificatesRequest(int? maxresults, DateTimeOffset? ocpDate, int? timeOut, string filter, IEnumerable<string> select, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/certificates", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (maxresults != null)
            {
                uri.AppendQuery("maxresults", maxresults.Value, true);
            }
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            if (filter != null)
            {
                uri.AppendQuery("$filter", filter, true);
            }
            if (select != null && Optional.IsCollectionDefined(select))
            {
                uri.AppendQueryDelimited("$select", select, ",", true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            return message;
        }

        internal HttpMessage CreateCancelCertificateDeletionRequest(string thumbprintAlgorithm, string thumbprint, int? timeOut, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/certificates(thumbprintAlgorithm=", false);
            uri.AppendPath(thumbprintAlgorithm, true);
            uri.AppendPath(",thumbprint=", false);
            uri.AppendPath(thumbprint, true);
            uri.AppendPath(")/canceldelete", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            return message;
        }

        internal HttpMessage CreateDeleteCertificateRequest(string thumbprintAlgorithm, string thumbprint, int? timeOut, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/certificates(thumbprintAlgorithm=", false);
            uri.AppendPath(thumbprintAlgorithm, true);
            uri.AppendPath(",thumbprint=", false);
            uri.AppendPath(thumbprint, true);
            uri.AppendPath(")", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            return message;
        }

        internal HttpMessage CreateGetCertificateRequest(string thumbprintAlgorithm, string thumbprint, int? timeOut, DateTimeOffset? ocpDate, IEnumerable<string> select, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/certificates(thumbprintAlgorithm=", false);
            uri.AppendPath(thumbprintAlgorithm, true);
            uri.AppendPath(",thumbprint=", false);
            uri.AppendPath(thumbprint, true);
            uri.AppendPath(")", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            if (select != null && Optional.IsCollectionDefined(select))
            {
                uri.AppendQueryDelimited("$select", select, ",", true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            return message;
        }

        internal HttpMessage CreateJobScheduleExistsRequest(string jobScheduleId, int? timeOut, DateTimeOffset? ocpDate, RequestConditions requestConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200To300400To500);
            var request = message.Request;
            request.Method = RequestMethod.Head;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/jobschedules/", false);
            uri.AppendPath(jobScheduleId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            if (requestConditions != null)
            {
                request.Headers.Add(requestConditions, "R");
            }
            return message;
        }

        internal HttpMessage CreateDeleteJobScheduleRequest(string jobScheduleId, int? timeOut, DateTimeOffset? ocpDate, RequestConditions requestConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/jobschedules/", false);
            uri.AppendPath(jobScheduleId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            if (requestConditions != null)
            {
                request.Headers.Add(requestConditions, "R");
            }
            return message;
        }

        internal HttpMessage CreateGetJobScheduleRequest(string jobScheduleId, int? timeOut, DateTimeOffset? ocpDate, IEnumerable<string> select, IEnumerable<string> expand, RequestConditions requestConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/jobschedules/", false);
            uri.AppendPath(jobScheduleId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            if (select != null && Optional.IsCollectionDefined(select))
            {
                uri.AppendQueryDelimited("$select", select, ",", true);
            }
            if (expand != null && Optional.IsCollectionDefined(expand))
            {
                uri.AppendQueryDelimited("$expand", expand, ",", true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            if (requestConditions != null)
            {
                request.Headers.Add(requestConditions, "R");
            }
            return message;
        }

        internal HttpMessage CreateUpdateJobScheduleRequest(string jobScheduleId, RequestContent content, int? timeOut, DateTimeOffset? ocpDate, RequestConditions requestConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/jobschedules/", false);
            uri.AppendPath(jobScheduleId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            if (requestConditions != null)
            {
                request.Headers.Add(requestConditions, "R");
            }
            request.Headers.Add("content-type", "application/json; odata=minimalmetadata");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateReplaceJobScheduleRequest(string jobScheduleId, RequestContent content, int? timeOut, DateTimeOffset? ocpDate, RequestConditions requestConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/jobschedules/", false);
            uri.AppendPath(jobScheduleId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            if (requestConditions != null)
            {
                request.Headers.Add(requestConditions, "R");
            }
            request.Headers.Add("content-type", "application/json; odata=minimalmetadata");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDisableJobScheduleRequest(string jobScheduleId, int? timeOut, DateTimeOffset? ocpDate, RequestConditions requestConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/jobschedules/", false);
            uri.AppendPath(jobScheduleId, true);
            uri.AppendPath("/disable", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            if (requestConditions != null)
            {
                request.Headers.Add(requestConditions, "R");
            }
            return message;
        }

        internal HttpMessage CreateEnableJobScheduleRequest(string jobScheduleId, int? timeOut, DateTimeOffset? ocpDate, RequestConditions requestConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/jobschedules/", false);
            uri.AppendPath(jobScheduleId, true);
            uri.AppendPath("/enable", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            if (requestConditions != null)
            {
                request.Headers.Add(requestConditions, "R");
            }
            return message;
        }

        internal HttpMessage CreateTerminateJobScheduleRequest(string jobScheduleId, int? timeOut, DateTimeOffset? ocpDate, RequestConditions requestConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/jobschedules/", false);
            uri.AppendPath(jobScheduleId, true);
            uri.AppendPath("/terminate", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            if (requestConditions != null)
            {
                request.Headers.Add(requestConditions, "R");
            }
            return message;
        }

        internal HttpMessage CreateCreateJobScheduleRequest(RequestContent content, int? timeOut, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier201);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/jobschedules", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("content-type", "application/json; odata=minimalmetadata");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetJobSchedulesRequest(int? maxresults, DateTimeOffset? ocpDate, int? timeOut, string filter, IEnumerable<string> select, IEnumerable<string> expand, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/jobschedules", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (maxresults != null)
            {
                uri.AppendQuery("maxresults", maxresults.Value, true);
            }
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            if (filter != null)
            {
                uri.AppendQuery("$filter", filter, true);
            }
            if (select != null && Optional.IsCollectionDefined(select))
            {
                uri.AppendQueryDelimited("$select", select, ",", true);
            }
            if (expand != null && Optional.IsCollectionDefined(expand))
            {
                uri.AppendQueryDelimited("$expand", expand, ",", true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            return message;
        }

        internal HttpMessage CreateCreateTaskRequest(string jobId, RequestContent content, int? timeOut, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier201);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/tasks", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("content-type", "application/json; odata=minimalmetadata");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetTasksRequest(string jobId, int? maxresults, DateTimeOffset? ocpDate, int? timeOut, string filter, IEnumerable<string> select, IEnumerable<string> expand, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/tasks", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (maxresults != null)
            {
                uri.AppendQuery("maxresults", maxresults.Value, true);
            }
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            if (filter != null)
            {
                uri.AppendQuery("$filter", filter, true);
            }
            if (select != null && Optional.IsCollectionDefined(select))
            {
                uri.AppendQueryDelimited("$select", select, ",", true);
            }
            if (expand != null && Optional.IsCollectionDefined(expand))
            {
                uri.AppendQueryDelimited("$expand", expand, ",", true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            return message;
        }

        internal HttpMessage CreateCreateTaskCollectionRequest(string jobId, RequestContent content, int? timeOut, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/addtaskcollection", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("content-type", "application/json; odata=minimalmetadata");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteTaskRequest(string jobId, string taskId, int? timeOut, DateTimeOffset? ocpDate, RequestConditions requestConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/tasks/", false);
            uri.AppendPath(taskId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            if (requestConditions != null)
            {
                request.Headers.Add(requestConditions, "R");
            }
            return message;
        }

        internal HttpMessage CreateGetTaskRequest(string jobId, string taskId, int? timeOut, DateTimeOffset? ocpDate, IEnumerable<string> select, IEnumerable<string> expand, RequestConditions requestConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/tasks/", false);
            uri.AppendPath(taskId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            if (select != null && Optional.IsCollectionDefined(select))
            {
                uri.AppendQueryDelimited("$select", select, ",", true);
            }
            if (expand != null && Optional.IsCollectionDefined(expand))
            {
                uri.AppendQueryDelimited("$expand", expand, ",", true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            if (requestConditions != null)
            {
                request.Headers.Add(requestConditions, "R");
            }
            return message;
        }

        internal HttpMessage CreateReplaceTaskRequest(string jobId, string taskId, RequestContent content, int? timeOut, DateTimeOffset? ocpDate, RequestConditions requestConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/tasks/", false);
            uri.AppendPath(taskId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            if (requestConditions != null)
            {
                request.Headers.Add(requestConditions, "R");
            }
            request.Headers.Add("content-type", "application/json; odata=minimalmetadata");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetSubTasksRequest(string jobId, string taskId, int? timeOut, DateTimeOffset? ocpDate, IEnumerable<string> select, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/tasks/", false);
            uri.AppendPath(taskId, true);
            uri.AppendPath("/subtasksinfo", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            if (select != null && Optional.IsCollectionDefined(select))
            {
                uri.AppendQueryDelimited("$select", select, ",", true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            return message;
        }

        internal HttpMessage CreateTerminateTaskRequest(string jobId, string taskId, int? timeOut, DateTimeOffset? ocpDate, RequestConditions requestConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/tasks/", false);
            uri.AppendPath(taskId, true);
            uri.AppendPath("/terminate", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            if (requestConditions != null)
            {
                request.Headers.Add(requestConditions, "R");
            }
            return message;
        }

        internal HttpMessage CreateReactivateTaskRequest(string jobId, string taskId, int? timeOut, DateTimeOffset? ocpDate, RequestConditions requestConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/tasks/", false);
            uri.AppendPath(taskId, true);
            uri.AppendPath("/reactivate", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            if (requestConditions != null)
            {
                request.Headers.Add(requestConditions, "R");
            }
            return message;
        }

        internal HttpMessage CreateDeleteTaskFileRequest(string jobId, string taskId, string filePath, int? timeOut, DateTimeOffset? ocpDate, bool? recursive, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/tasks/", false);
            uri.AppendPath(taskId, true);
            uri.AppendPath("/files/", false);
            uri.AppendPath(filePath, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            if (recursive != null)
            {
                uri.AppendQuery("recursive", recursive.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            return message;
        }

        internal HttpMessage CreateGetTaskFileRequest(string jobId, string taskId, string filePath, int? timeOut, DateTimeOffset? ocpDate, string ocpRange, RequestConditions requestConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/tasks/", false);
            uri.AppendPath(taskId, true);
            uri.AppendPath("/files/", false);
            uri.AppendPath(filePath, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            if (ocpRange != null)
            {
                request.Headers.Add("ocp-range", ocpRange);
            }
            if (requestConditions != null)
            {
                request.Headers.Add(requestConditions, "R");
            }
            return message;
        }

        internal HttpMessage CreateGetTaskFilePropertiesRequest(string jobId, string taskId, string filePath, int? timeOut, DateTimeOffset? ocpDate, RequestConditions requestConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200To300400To500);
            var request = message.Request;
            request.Method = RequestMethod.Head;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/tasks/", false);
            uri.AppendPath(taskId, true);
            uri.AppendPath("/files/", false);
            uri.AppendPath(filePath, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            if (requestConditions != null)
            {
                request.Headers.Add(requestConditions, "R");
            }
            return message;
        }

        internal HttpMessage CreateGetTaskFilesRequest(string jobId, string taskId, int? maxresults, DateTimeOffset? ocpDate, int? timeOut, string filter, bool? recursive, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/jobs/", false);
            uri.AppendPath(jobId, true);
            uri.AppendPath("/tasks/", false);
            uri.AppendPath(taskId, true);
            uri.AppendPath("/files", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (maxresults != null)
            {
                uri.AppendQuery("maxresults", maxresults.Value, true);
            }
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            if (filter != null)
            {
                uri.AppendQuery("$filter", filter, true);
            }
            if (recursive != null)
            {
                uri.AppendQuery("recursive", recursive.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            return message;
        }

        internal HttpMessage CreateCreateNodeUserRequest(string poolId, string nodeId, RequestContent content, int? timeOut, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier201);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/users", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("content-type", "application/json; odata=minimalmetadata");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteNodeUserRequest(string poolId, string nodeId, string userName, int? timeOut, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/users/", false);
            uri.AppendPath(userName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            return message;
        }

        internal HttpMessage CreateReplaceNodeUserRequest(string poolId, string nodeId, string userName, RequestContent content, int? timeOut, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/users/", false);
            uri.AppendPath(userName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("content-type", "application/json; odata=minimalmetadata");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetNodeRequest(string poolId, string nodeId, int? timeOut, DateTimeOffset? ocpDate, IEnumerable<string> select, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            if (select != null && Optional.IsCollectionDefined(select))
            {
                uri.AppendQueryDelimited("$select", select, ",", true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            return message;
        }

        internal HttpMessage CreateRebootNodeRequest(string poolId, string nodeId, RequestContent content, int? timeOut, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/reboot", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("content-type", "application/json; odata=minimalmetadata");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateReimageNodeRequest(string poolId, string nodeId, RequestContent content, int? timeOut, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/reimage", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("content-type", "application/json; odata=minimalmetadata");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDisableNodeSchedulingRequest(string poolId, string nodeId, RequestContent content, int? timeOut, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/disablescheduling", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("content-type", "application/json; odata=minimalmetadata");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateEnableNodeSchedulingRequest(string poolId, string nodeId, int? timeOut, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/enablescheduling", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            return message;
        }

        internal HttpMessage CreateGetNodeRemoteLoginSettingsRequest(string poolId, string nodeId, int? timeOut, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/remoteloginsettings", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            return message;
        }

        internal HttpMessage CreateGetNodeRemoteDesktopFileRequest(string poolId, string nodeId, int? timeOut, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/rdp", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            return message;
        }

        internal HttpMessage CreateUploadNodeLogsRequest(string poolId, string nodeId, RequestContent content, int? timeOut, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/uploadbatchservicelogs", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("content-type", "application/json; odata=minimalmetadata");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetNodesRequest(string poolId, int? maxresults, DateTimeOffset? ocpDate, int? timeOut, string filter, IEnumerable<string> select, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (maxresults != null)
            {
                uri.AppendQuery("maxresults", maxresults.Value, true);
            }
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            if (filter != null)
            {
                uri.AppendQuery("$filter", filter, true);
            }
            if (select != null && Optional.IsCollectionDefined(select))
            {
                uri.AppendQueryDelimited("$select", select, ",", true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            return message;
        }

        internal HttpMessage CreateGetNodeExtensionRequest(string poolId, string nodeId, string extensionName, int? timeOut, DateTimeOffset? ocpDate, IEnumerable<string> select, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/extensions/", false);
            uri.AppendPath(extensionName, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            if (select != null && Optional.IsCollectionDefined(select))
            {
                uri.AppendQueryDelimited("$select", select, ",", true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            return message;
        }

        internal HttpMessage CreateGetNodeExtensionsRequest(string poolId, string nodeId, int? maxresults, DateTimeOffset? ocpDate, int? timeOut, IEnumerable<string> select, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/extensions", false);
            if (maxresults != null)
            {
                uri.AppendQuery("maxresults", maxresults.Value, true);
            }
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            if (select != null && Optional.IsCollectionDefined(select))
            {
                uri.AppendQueryDelimited("$select", select, ",", true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            return message;
        }

        internal HttpMessage CreateDeleteNodeFileRequest(string poolId, string nodeId, string filePath, int? timeOut, DateTimeOffset? ocpDate, bool? recursive, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/files/", false);
            uri.AppendPath(filePath, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            if (recursive != null)
            {
                uri.AppendQuery("recursive", recursive.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            return message;
        }

        internal HttpMessage CreateGetNodeFileRequest(string poolId, string nodeId, string filePath, int? timeOut, DateTimeOffset? ocpDate, string ocpRange, RequestConditions requestConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/files/", false);
            uri.AppendPath(filePath, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            if (ocpRange != null)
            {
                request.Headers.Add("ocp-range", ocpRange);
            }
            if (requestConditions != null)
            {
                request.Headers.Add(requestConditions, "R");
            }
            return message;
        }

        internal HttpMessage CreateGetNodeFilePropertiesRequest(string poolId, string nodeId, string filePath, int? timeOut, DateTimeOffset? ocpDate, RequestConditions requestConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200To300400To500);
            var request = message.Request;
            request.Method = RequestMethod.Head;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/files/", false);
            uri.AppendPath(filePath, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            if (requestConditions != null)
            {
                request.Headers.Add(requestConditions, "R");
            }
            return message;
        }

        internal HttpMessage CreateGetNodeFilesRequest(string poolId, string nodeId, int? maxresults, DateTimeOffset? ocpDate, int? timeOut, string filter, bool? recursive, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/files", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (maxresults != null)
            {
                uri.AppendQuery("maxresults", maxresults.Value, true);
            }
            if (timeOut != null)
            {
                uri.AppendQuery("timeOut", timeOut.Value, true);
            }
            if (filter != null)
            {
                uri.AppendQuery("$filter", filter, true);
            }
            if (recursive != null)
            {
                uri.AppendQuery("recursive", recursive.Value, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("client-request-id", message.Request.ClientRequestId);
            request.Headers.Add("return-client-request-id", "true");
            return message;
        }

        private static RequestContext DefaultRequestContext = new RequestContext();
        internal static RequestContext FromCancellationToken(CancellationToken cancellationToken = default)
        {
            if (!cancellationToken.CanBeCanceled)
            {
                return DefaultRequestContext;
            }

            return new RequestContext() { CancellationToken = cancellationToken };
        }

        private static ResponseClassifier _responseClassifier200;
        private static ResponseClassifier ResponseClassifier200 => _responseClassifier200 ??= new StatusCodeClassifier(stackalloc ushort[] { 200 });
        private static ResponseClassifier _responseClassifier201;
        private static ResponseClassifier ResponseClassifier201 => _responseClassifier201 ??= new StatusCodeClassifier(stackalloc ushort[] { 201 });
        private static ResponseClassifier _responseClassifier202;
        private static ResponseClassifier ResponseClassifier202 => _responseClassifier202 ??= new StatusCodeClassifier(stackalloc ushort[] { 202 });
        private sealed class ResponseClassifier200To300400To500Override : ResponseClassifier
        {
            public override bool IsErrorResponse(HttpMessage message)
            {
                return message.Response.Status switch
                {
                    >= 200 and < 300 => false,
                    >= 400 and < 500 => false,
                    _ => true
                };
            }
        }

        private static ResponseClassifier _responseClassifier200To300400To500;
        private static ResponseClassifier ResponseClassifier200To300400To500 => _responseClassifier200To300400To500 ??= new ResponseClassifier200To300400To500Override();
        private static ResponseClassifier _responseClassifier204;
        private static ResponseClassifier ResponseClassifier204 => _responseClassifier204 ??= new StatusCodeClassifier(stackalloc ushort[] { 204 });
    }
}
